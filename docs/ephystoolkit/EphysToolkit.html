<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 10.0.3"/>
    <title>ephystoolkit.EphysToolkit API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc section{margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;cursor:pointer;}.pdoc details > summary:focus{outline:0;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:2.5rem;}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>




        <h2>API Documentation</h2>
            <ul class="memberlist">
            <li>
                    <a class="class" href="#ephys_toolkit">ephys_toolkit</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#ephys_toolkit.__init__">ephys_toolkit</a>
                        </li>
                        <li>
                                <a class="function" href="#ephys_toolkit.static_grating">static_grating</a>
                        </li>
                        <li>
                                <a class="function" href="#ephys_toolkit.drifting_grating">drifting_grating</a>
                        </li>
                        <li>
                                <a class="function" href="#ephys_toolkit.spike_sorting_metrics">spike_sorting_metrics</a>
                        </li>
                        <li>
                                <a class="function" href="#ephys_toolkit.raster">raster</a>
                        </li>
                        <li>
                                <a class="function" href="#ephys_toolkit.avg_across_param">avg_across_param</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#load_experiment">load_experiment</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#load_experiment.__init__">load_experiment</a>
                        </li>
                        <li>
                                <a class="function" href="#load_experiment.set_time_unit">set_time_unit</a>
                        </li>
                        <li>
                                <a class="function" href="#load_experiment.condition_times">condition_times</a>
                        </li>
                        <li>
                                <a class="function" href="#load_experiment.match_condition_parameters">match_condition_parameters</a>
                        </li>
                        <li>
                                <a class="function" href="#load_experiment.population_response">population_response</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#load_project">load_project</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#load_project.__init__">load_project</a>
                        </li>
                </ul>

            </li>
    </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
ephystoolkit<wbr>.EphysToolkit    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="c1"># class imports</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.io</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>

<span class="kn">from</span> <span class="nn">pathexplorer.PathExplorer</span> <span class="kn">import</span> <span class="n">path_explorer</span>


<span class="k">class</span> <span class="nc">ephys_toolkit</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SAMPLING_RATE</span> <span class="o">=</span> <span class="mi">20000</span>

    <span class="k">def</span> <span class="nf">_bin_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="n">bin_size</span> <span class="o">**</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numerator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SAMPLING_RATE</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span>

        <span class="k">return</span> <span class="n">events</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">numerator</span>

    <span class="k">def</span> <span class="nf">_minmax_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize an array with minmax normalization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">array</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">array</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_zscore_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize an array with z score normalization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_average_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">stim_reps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the average frequency of a unit&#39;s response</span>
<span class="sd">        across stimulus repeats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">array</span> <span class="o">/</span> <span class="n">stim_reps</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span>
    
    <span class="k">def</span> <span class="nf">static_grating</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">windowSizeX_Pixel</span><span class="p">,</span> <span class="n">windowSizeY_Pixel</span><span class="p">,</span> <span class="c1"># size of the stimulus window in pixels</span>
            <span class="n">windowSizeX_Visual</span><span class="p">,</span> <span class="n">windowSizeY_Visual</span><span class="p">,</span> <span class="c1"># size of the stimulus window in degrees</span>
            <span class="n">spatialFrequency</span><span class="p">,</span> <span class="c1"># spatial frequency in cpd</span>
            <span class="n">ang</span><span class="p">,</span> <span class="c1"># orientation angle of the grating in degrees</span>
            <span class="n">phi</span><span class="p">,</span> <span class="c1"># phase of the grating in degrees</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># dimater of the circular patch in degrees</span>
    <span class="p">):</span>    
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a matrix of pixel intensities   </span>
<span class="sd">        representing a static grating stimulus</span>
<span class="sd">        with the given parameters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - windowSizeX_Pixel: Horizontal size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeY_Pixel: Vertical size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeX_Visual: Horizontal size of the stimulus screen in degrees.</span>
<span class="sd">        - windowSizeY_Visual: Vertical size of the stimulus screen in degrees.</span>
<span class="sd">        - spatialFrequency: Spatial frequency in cycles per degre (cpd).</span>
<span class="sd">        - ang: Orientation angle of the grating in degrees.</span>
<span class="sd">        - phi: Phase of the grating in degrees</span>
<span class="sd">        - diameter: Dimater of the circular patch in degrees. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="p">((</span><span class="n">windowSizeX_Pixel</span> <span class="o">&lt;=</span><span class="mi">10</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">windowSizeX_Pixel</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;windowSizeX_Pixel must be greater than ten and even&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">windowSizeY_Pixel</span> <span class="o">&lt;=</span><span class="mi">10</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">windowSizeY_Pixel</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;windowSizeY_Pixel must be greater than ten and even&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">windowSizeX_Pixel</span><span class="o">/</span><span class="n">windowSizeY_Pixel</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> 
            <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">windowSizeX_Visual</span><span class="o">/</span><span class="n">windowSizeY_Visual</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The ratio of X and Y for Pixel and Visual are different!&#39;</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">spatialFrequency</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">error</span><span class="p">(</span><span class="s1">&#39;spatialFrequency less than zero&#39;</span><span class="p">)</span>

        <span class="c1"># x, y </span>
        <span class="n">x_center</span> <span class="o">=</span> <span class="n">windowSizeX_Pixel</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">y_center</span> <span class="o">=</span> <span class="n">windowSizeY_Pixel</span><span class="o">/</span><span class="mi">2</span>

        <span class="n">x_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">x_center</span><span class="p">,</span> <span class="n">x_center</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">y_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">y_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span><span class="n">y_range</span><span class="p">)</span>

        <span class="c1"># theta</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ang</span><span class="p">);</span>
        <span class="n">xyTheta</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>

        <span class="c1"># Spatial Frenquency</span>
        <span class="n">degreePerPixel</span> <span class="o">=</span> <span class="n">windowSizeX_Visual</span> <span class="o">/</span> <span class="n">windowSizeX_Pixel</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">spatialFrequency</span>  <span class="o">*</span> <span class="n">degreePerPixel</span> <span class="c1"># cycles / pixel</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sf</span> <span class="c1"># radian / pixel</span>

        <span class="c1"># contrast</span>
        <span class="n">pixelIntensity</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sw</span> <span class="o">*</span> <span class="n">xyTheta</span> <span class="o">-</span> <span class="n">phi</span><span class="p">))</span> <span class="c1"># range: -1 to 1</span>

        <span class="c1"># round image</span>
        <span class="k">if</span> <span class="n">diameter</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">/</span> <span class="n">degreePerPixel</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">diameter</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
            <span class="n">c_mask</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
            <span class="n">pixelIntensity</span> <span class="o">=</span> <span class="n">pixelIntensity</span><span class="o">*</span><span class="n">c_mask</span> 

        <span class="k">return</span> <span class="n">pixelIntensity</span>

    <span class="k">def</span> <span class="nf">drifting_grating</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">windowSizeX_Pixel</span><span class="p">,</span> <span class="n">windowSizeY_Pixel</span><span class="p">,</span> <span class="c1"># size of the stimulus window in pixels</span>
            <span class="n">windowSizeX_Visual</span><span class="p">,</span> <span class="n">windowSizeY_Visual</span><span class="p">,</span> <span class="c1"># size of the stimulus window in degrees</span>
            <span class="n">tf</span><span class="p">,</span>  <span class="c1"># Temporal frequency - pass as an integer or floating point value</span>
            <span class="n">dt</span><span class="p">,</span>  <span class="c1"># Time step value - pass as a floating point value</span>
            <span class="n">t</span><span class="p">,</span>  <span class="c1"># Total duration of the stimulus - pass as an int or float of the appropriate time unit</span>
            <span class="n">spatialFrequency</span><span class="p">,</span> <span class="c1"># spatial frequency in cpd</span>
            <span class="n">ang</span><span class="p">,</span> <span class="c1"># orientation angle of the grating in degrees</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># dimater of the circular patch in degrees</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of matricies representing</span>
<span class="sd">        frames of a drifitng grating stimulus.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        - windowSizeX_Pixel: Horizontal size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeY_Pixel: Vertical size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeX_Visual: Horizontal size of the stimulus screen in degrees.</span>
<span class="sd">        - windowSizeY_Visual: Vertical size of the stimulus screen in degrees.    </span>
<span class="sd">        - tf: Temporal frequency - pass as an integer or floating point value.</span>
<span class="sd">        - dt: Time step value - pass as a floating point value.</span>
<span class="sd">        - t: Total duration of the stimulus - pass as an int or float of the appropriate time unit.</span>
<span class="sd">        - spatialFrequency: Spatial frequency in cycles per degre (cpd).</span>
<span class="sd">        - ang: Orientation angle of the grating in degrees.</span>
<span class="sd">        - diameter: Dimater of the circular patch in degrees. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tensor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deg_step</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="mi">360</span> <span class="o">*</span> <span class="n">tf</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_grating</span><span class="p">(</span>
                <span class="n">windowSizeX_Pixel</span><span class="p">,</span> <span class="n">windowSizeY_Pixel</span><span class="p">,</span> 
                <span class="n">windowSizeX_Visual</span><span class="p">,</span> <span class="n">windowSizeY_Visual</span><span class="p">,</span> 
                <span class="n">spatialFrequency</span><span class="p">,</span>
                <span class="n">ang</span><span class="p">,</span>
                <span class="n">phi</span><span class="p">,</span>
                <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span>
            <span class="p">)</span> 
            <span class="n">tensor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">sf</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">ori</span><span class="p">,</span> <span class="n">phase</span><span class="p">])</span>
            <span class="n">phi</span> <span class="o">+=</span> <span class="n">deg_step</span>

        <span class="k">return</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">_discrete_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        

        <span class="n">m</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="o">&lt;</span> <span class="p">((</span><span class="n">radius</span> <span class="o">/</span> <span class="mi">360</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)):</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">_gaussian_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">sigma</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">/</span> <span class="mi">360</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">d</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">spike_sorting_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dataframe with the spike sorting metrics</span>
<span class="sd">        of a given recording section.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - file_path: Path to the spike sorting metrics file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">sorting_file</span><span class="p">:</span>
            <span class="n">sorting_info</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sorting_file</span><span class="p">)</span>

        <span class="n">spike_sorting_data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># [cluster[&#39;label&#39;] for cluster in sorting_info[&#39;clusters&#39;]],</span>
            <span class="p">[</span><span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;metrics&#39;</span><span class="p">][</span><span class="s1">&#39;isolation&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">sorting_info</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;metrics&#39;</span><span class="p">][</span><span class="s1">&#39;noise_overlap&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">sorting_info</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]]</span>
        <span class="p">]</span>

        <span class="n">ss_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spike_sorting_data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">ss_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># &#39;cluster&#39;, </span>
            <span class="s1">&#39;isolation&#39;</span><span class="p">,</span> <span class="s1">&#39;noise_overlap&#39;</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">ss_df</span>

    <span class="c1"># functions to make concatenated across trial and non concatenated across trial rasters</span>
    <span class="k">def</span> <span class="nf">_concatenated_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stims</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thresh</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spikes</span> <span class="o">-</span> <span class="n">st</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stims</span><span class="p">])</span>
            <span class="n">raster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spikes</span> <span class="o">-</span> <span class="n">st</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stims</span><span class="p">])</span>
            <span class="n">ti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">raster</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">raster</span>

    <span class="k">def</span> <span class="nf">_unconcatenated_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stims</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thresh</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">rasters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spikes</span> <span class="o">-</span> <span class="n">st</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stims</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rasters</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stims</span><span class="p">):</span>  <span class="c1"># enumerate to make an initial array then vstack</span>
                <span class="n">unthreshed</span> <span class="o">=</span> <span class="n">spikes</span> <span class="o">-</span> <span class="n">st</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">unthreshed</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unthreshed</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">rasters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">unthreshed</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">rasters</span>

    <span class="k">def</span> <span class="nf">raster</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">stims</span><span class="p">,</span>  <span class="c1"># Array of stimulus onset times</span>
            <span class="n">spikes</span><span class="p">,</span>  <span class="c1"># Array of spike onset times</span>
            <span class="n">thresh</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span>  <span class="c1"># Bounding threshold around the stimulus onset at t = 0 - pass as a tuple</span>
            <span class="n">concatenate</span><span class="o">=</span><span class="kc">True</span>  <span class="c1"># Concatenate rasters across trials - pass False to return unconcatenated rasters</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an array representing a raster of spike times centered </span>
<span class="sd">        around the onset times of a given stimulus.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - stims: Array of stimulus onset times.</span>
<span class="sd">        - spikes: Array of spike onset times.</span>
<span class="sd">        - thresh: Bounding threshold around the stimulus onset at t = 0 - pass as a tuple.</span>
<span class="sd">        - concatenate: Concatenate rasters across trials; pass False to return unconcatenated rasters.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">concatenate</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenated_raster</span><span class="p">(</span><span class="n">stims</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unconcatenated_raster</span><span class="p">(</span><span class="n">stims</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">avg_across_param</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">pop_resp</span><span class="p">,</span> <span class="c1"># this df must have cluster ids as columns</span>
            <span class="n">col_param</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="c1"># parameter whose values are to be shown in the columns</span>
            <span class="n">avg_param</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="c1"># parameters to average across</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dataframe showing responses as a function one parameter while averaging</span>
<span class="sd">        over the other parameters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        - pop_resp: A dataframe of the population response in which the columns are units.</span>
<span class="sd">        - col_param: The parameter to show in the columns.</span>
<span class="sd">        - avg_param: The parameter(s) to average across.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># groupby the parameter of interest</span>
        <span class="n">gb</span> <span class="o">=</span> <span class="n">pop_resp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_param</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># get an array of the column values and cluster ids</span>
        <span class="n">col_values</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gb</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)]</span>

        <span class="c1"># initialize dictionary for cross parameter averaged data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cluster&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">col_values</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># create the cluster id column</span>
        <span class="k">for</span> <span class="n">unit_id</span> <span class="ow">in</span> <span class="n">units</span><span class="p">:</span>
            <span class="n">unit_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">unit_id</span><span class="p">]</span><span class="o">*</span><span class="mi">500</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">],</span> <span class="n">unit_ids</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># get the number of parameter combos and length of response</span>
        <span class="n">param_combos</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">avg_param</span><span class="p">:</span>
            <span class="n">param_combos</span><span class="o">*=</span><span class="nb">len</span><span class="p">(</span><span class="n">pop_resp</span><span class="p">[</span><span class="n">param</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">resp_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_resp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pop_resp</span><span class="o">.</span><span class="n">stimulus_condition</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>

         <span class="c1"># create the firing rate value columns</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">col_values</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">unit_id</span> <span class="ow">in</span> <span class="n">units</span><span class="p">:</span>
                    <span class="n">cc_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gb</span><span class="p">[</span><span class="n">unit_id</span><span class="p">][</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">param_combos</span><span class="p">,</span><span class="n">resp_len</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">cc_avg</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                        Failed to reshape response array. </span>
<span class="s2">                        Make sure col_param is not repeated</span>
<span class="s2">                        in avg_param.</span>
<span class="s2">                        &quot;&quot;&quot;</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">load_experiment</span><span class="p">(</span><span class="n">ephys_toolkit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an experiment object for a given recording block.</span>
<span class="sd">    Takes the spike data file path as the first argument and the</span>
<span class="sd">    stimulus data file path as the second argument. Initializing</span>
<span class="sd">    an experiment object generates some important class attributes:</span>
<span class="sd">    </span>
<span class="sd">    .stim_data: A pandas dataframe with the stimulus data.</span>
<span class="sd">    </span>
<span class="sd">    .spike_data: A dictionary object with the spiking data</span>
<span class="sd">                 of all the identified clusters.</span>
<span class="sd">                 </span>
<span class="sd">    Args:</span>
<span class="sd">    </span>
<span class="sd">    - spikefile: Path to the spike data file.</span>
<span class="sd">    - stimfile: Path to the stimulus data file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikefile</span><span class="p">,</span> <span class="n">stimfile</span><span class="p">,</span> <span class="n">logfile</span><span class="p">):</span>
        <span class="n">ephys_toolkit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">spikes_mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">spikefile</span><span class="p">)</span>
        <span class="n">stims_mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">stimfile</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spikes</span> <span class="o">=</span> <span class="n">spikes_mat</span><span class="p">[</span><span class="s1">&#39;Data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stims</span> <span class="o">=</span> <span class="n">stims_mat</span><span class="p">[</span><span class="s1">&#39;StimulusData&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logfile</span> <span class="o">=</span> <span class="n">logfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_stim_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_spike_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_time_unit</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters_matched</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span>
            <span class="s1">&#39;stim_condition_ids&#39;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logfile</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_conditions_from_log</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;([A-Z]{1,2}_M\d{1,}_Section_\d{1,}_BLK\d{1,})&#39;</span>
            <span class="n">experiment_id</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">spikefile</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">warn_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            No stimulus log file found for experiment: </span><span class="si">{</span><span class="n">experiment_id</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">            If this experiment has more that 255 stimulus conditions, the stimulus </span>
<span class="s2">            condition IDs will be incorrect in the self.stim_data attribute.</span>
<span class="s2">            &quot;&quot;&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warn_text</span><span class="p">,</span> <span class="n">stacklevel</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Generates the .stim_data attribute.</span>
    <span class="k">def</span> <span class="nf">_init_stim_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">stims_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stims_stops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">stims_condition_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">stim_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">:</span> <span class="n">stims_starts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">:</span> <span class="n">stims_stops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;stim_condition_ids&#39;</span><span class="p">:</span> <span class="n">stims_condition_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">stim_data</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A pandas dataframe with the stimulus data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="c1"># Generates the .spike_data attribute.</span>
    <span class="k">def</span> <span class="nf">_init_spike_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spike_data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="c1"># &#39;cluster_id&#39;:unit[0][0][0],</span>
                <span class="s1">&#39;channel_id&#39;</span><span class="p">:</span> <span class="n">unit</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;spike_index&#39;</span><span class="p">:</span> <span class="n">unit</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;spike_time&#39;</span><span class="p">:</span> <span class="n">unit</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spikes</span>
        <span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary object with the spiking data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
    <span class="k">def</span> <span class="nf">_get_conditions_from_log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logfile</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">stimlog</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

        <span class="n">stimlog</span> <span class="o">=</span> <span class="n">stimlog</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="c1"># extract conditions for log</span>
        <span class="n">r0</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;[Cc]ondition#: *(\d{1,})&#39;</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;[Cc]onditions:(\d{1,} +...*)&#39;</span>
        <span class="n">condition_ids</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">stimlog</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># if the experiment is gratings or checkerboard</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">stimlog</span><span class="p">:</span>
                <span class="n">c_id</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">condition_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">c_id</span><span class="p">))</span>
                
            <span class="k">try</span><span class="p">:</span>  
                <span class="c1"># replace conditions in experiment with conditions from log</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span> <span class="o">=</span> <span class="n">condition_ids</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">stimlog</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># if the experiment is natural images</span>
            <span class="n">condition_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stimlog</span><span class="p">:</span>
                <span class="n">cindex</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># index where condition numbers begin</span>
                <span class="n">numbers</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">cindex</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="c1"># remove whitespace at the end</span>
                <span class="n">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="c1"># remove double spaces</span>
                <span class="n">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="c1"># split into a list of conditon numbers</span>
                <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span> <span class="c1"># format str into int</span>
                <span class="n">condition_ids</span> <span class="o">+=</span> <span class="n">numbers</span> <span class="c1">#collect condition ids</span>

            <span class="c1">## This horrible block of code is here because the stimData matlab</span>
            <span class="c1">## file is missing the data the last two stimulus repeats</span>
            <span class="c1">## so it is added manually until the stimData file generation is fixed</span>

            <span class="c1"># difference between consecutive start indicies</span>
            <span class="n">startindex_diff</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                             <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># difference between consecutive stop indicies</span>
            <span class="n">stopindex_diff</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                             <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># difference between consecutive start times</span>
            <span class="n">starttime_diff</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                             <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># difference between consecutive stop times</span>
            <span class="n">stoptime_diff</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                             <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># adding two additional start indicies </span>
            <span class="n">start_ind_fixed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">start_ind_fixed</span> <span class="o">=</span> <span class="n">start_ind_fixed</span> <span class="o">+</span> <span class="p">[</span><span class="n">start_ind_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-+</span><span class="n">startindex_diff</span><span class="p">,</span> 
                                                 <span class="n">start_ind_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">startindex_diff</span><span class="p">]</span>
            <span class="c1"># adding two additional stop indicies </span>
            <span class="n">stop_ind_fixed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">stop_ind_fixed</span> <span class="o">=</span> <span class="n">stop_ind_fixed</span> <span class="o">+</span> <span class="p">[</span><span class="n">stop_ind_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">stopindex_diff</span><span class="p">,</span> 
                                                 <span class="n">stop_ind_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">stopindex_diff</span><span class="p">]</span>

            <span class="c1"># adding two additional start times </span>
            <span class="n">start_time_fixed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">start_time_fixed</span> <span class="o">=</span> <span class="n">start_time_fixed</span> <span class="o">+</span> <span class="p">[</span><span class="n">start_time_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">starttime_diff</span><span class="p">,</span> 
                                                 <span class="n">start_time_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">starttime_diff</span><span class="p">]</span>
            <span class="c1"># adding two additional stop times </span>
            <span class="n">stop_time_fixed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">stop_time_fixed</span> <span class="o">=</span> <span class="n">stop_time_fixed</span> <span class="o">+</span> <span class="p">[</span><span class="n">stop_time_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">stoptime_diff</span><span class="p">,</span> 
                                                 <span class="n">stop_time_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">stoptime_diff</span><span class="p">]</span>

            <span class="c1"># fixed stim data dictionary</span>
            <span class="n">stim_data_fixed</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;stim_condition_ids&#39;</span><span class="p">:</span> <span class="n">condition_ids</span><span class="p">,</span>
                <span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">:</span> <span class="n">start_ind_fixed</span><span class="p">,</span>
                <span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">:</span> <span class="n">stop_ind_fixed</span><span class="p">,</span>
                <span class="s1">&#39;stim_start_times&#39;</span><span class="p">:</span> <span class="n">start_time_fixed</span><span class="p">,</span>
                <span class="s1">&#39;stim_stop_times&#39;</span><span class="p">:</span> <span class="n">stop_time_fixed</span>
            <span class="p">}</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">stim_data_fixed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            
    <span class="k">def</span> <span class="nf">set_time_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the time unit of the relative spike times.</span>
<span class="sd">        Give a bin size relative to 1 second.</span>
<span class="sd">        IE: If you want a 1 ms bin size, enter 0.001;</span>
<span class="sd">        if you want a 10 ms bin size, enter 0.01 etc.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - bin_size: Time unit given relative to 1 second. The default unit is 1ms/0.001s.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_events</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_events</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span>
            <span class="p">[</span><span class="s1">&#39;stim_condition_ids&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_start_times&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_data</span><span class="p">:</span>
            <span class="n">unit</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s1">&#39;rel_spike_time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_events</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span>
                                                   <span class="n">unit</span><span class="p">[</span><span class="s1">&#39;spike_index&#39;</span><span class="p">])</span>
            <span class="p">})</span>

    <span class="k">def</span> <span class="nf">condition_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary object of the start times and</span>
<span class="sd">        stop times of a particular stimulus condition.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        -condition: Condition id for the chosen stimulus condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">condition_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span>
        <span class="p">)</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">condition_stops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span>
        <span class="p">)</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="n">condition_starts</span><span class="p">,</span>
            <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="n">condition_stops</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">match_condition_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a parameters file and alters the .stim_data dataframe</span>
<span class="sd">        to match stimulus condition parameters to their corresponding </span>
<span class="sd">        condition id.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - params_file: Path to the stimulus parameters file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># </span>

        <span class="c1"># regex to get the parameter names + values</span>
        <span class="n">name_identifier</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;Var\d{1,}Val&#39;</span>
        <span class="n">val_identifier</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;var\d{1,}value&#39;</span>

        <span class="c1"># load the parameter file and extract the keys</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">params_file</span><span class="p">)</span>
        <span class="n">param_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="k">if</span> <span class="s1">&#39;fnames&#39;</span> <span class="ow">in</span> <span class="n">param_keys</span><span class="p">:</span> <span class="c1"># if experiment is natural images</span>
            
            <span class="c1"># get the stim file names</span>
            <span class="n">stim_file_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> 
                <span class="n">name</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">params_file</span><span class="p">)[</span><span class="s1">&#39;fnames&#39;</span><span class="p">]</span>
            <span class="p">]</span>
            
            <span class="c1"># make a dictionary for the parameter mapping</span>
            <span class="n">ni_filemap</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;condition&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;filter&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;file&#39;</span><span class="p">:</span> <span class="p">[]</span>
            <span class="p">}</span>
            
            <span class="c1"># match condition to parameters</span>
            <span class="n">freg</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;^[A-Z]{2,3}&#39;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># if condition is even</span>
                    
                    <span class="c1">#append condition &amp; size</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
                    
                    <span class="c1">#append filename</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="n">stim_file_names</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> 
                    
                    <span class="c1">#append filtering condition</span>
                    <span class="n">filt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">freg</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
            
                <span class="k">else</span><span class="p">:</span> <span class="c1"># if condition is odd</span>
                    <span class="c1">#append condition &amp; size</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
                    
                    <span class="c1">#append filename</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="n">stim_file_names</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                    
                    <span class="c1">#append filtering condition</span>
                    <span class="n">filt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">freg</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
                    
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ni_filemap</span><span class="p">)</span> 
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span>
            
            <span class="c1"># get the parameters to insert into the original dataframe</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">condition</span> <span class="o">==</span> <span class="n">cond</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">insert</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">insert</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># insert the parameter values into the original dataframe</span>
            <span class="n">df1</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">insert</span><span class="p">)</span>

            <span class="c1"># reset the stim_data attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="n">df1</span><span class="p">[</span>
                <span class="nb">list</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">)</span>
                <span class="p">]</span>
        
        <span class="k">else</span><span class="p">:</span> <span class="c1"># if experiment is gratings or checkerboard</span>
            <span class="c1"># use regex to get the param names and values</span>
            <span class="n">name_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">param_keys</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">name_identifier</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>
            <span class="n">val_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">param_keys</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">val_identifier</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>

            <span class="c1"># get the condition numbers</span>
            <span class="n">condition_range</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">val_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">condition_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">condition_range</span><span class="p">)]</span>

            <span class="c1"># map conditions to parameter values</span>
            <span class="n">parameter_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;condition&#39;</span><span class="p">:</span> <span class="n">condition_ids</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">name_keys</span><span class="p">)):</span>
                <span class="n">parameter_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">name_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">parameter_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">val_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">parameter_map</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter_values</span>

                <span class="c1"># parameter dataframe + the original stim_data dataframe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">parameter_map</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span>

            <span class="c1"># get the parameters to insert into the original dataframe</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">condition</span> <span class="o">==</span> <span class="n">cond</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">insert</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">insert</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># insert the parameter values into the original dataframe</span>
            <span class="n">df1</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">insert</span><span class="p">)</span>

            <span class="c1"># reset the stim_data attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="n">df1</span><span class="p">[</span>
                <span class="nb">list</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">)</span>
                <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters_matched</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_pr_unitcols</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">include_units</span><span class="p">,</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span> 
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">thresh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Please provide a response boundary threshhold as a tuple (ex: (-50,500))&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thresh_min</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">thresh_max</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span>

        <span class="k">if</span> <span class="n">stim_condition</span> <span class="ow">is</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">stim_condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span>

        <span class="n">population</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cond_col</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">param_col</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">stim_condition</span><span class="p">:</span>
            <span class="n">condition_start_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">condition_times</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">include_units</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">cluster_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                    <span class="n">unit_spike_times</span> <span class="o">=</span> <span class="n">cluster_id</span>
                    <span class="n">cluster_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;n</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit_spike_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_data</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">][</span><span class="s1">&#39;rel_spike_time&#39;</span><span class="p">]</span>

                <span class="c1"># Raster</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raster</span><span class="p">(</span>
                    <span class="n">condition_start_times</span><span class="p">,</span> 
                    <span class="n">unit_spike_times</span><span class="p">,</span>
                    <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">)</span>

                <span class="c1"># Raster to histogram </span>
                <span class="n">h</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> 
                    <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">thresh_min</span><span class="p">,</span><span class="n">thresh_max</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Nonresponsive unit histogram</span>
                <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">h</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>

                <span class="c1"># Normalize the response</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                    <span class="n">norm_method</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;minmax&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minmax_norm</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
                        <span class="s1">&#39;zscore&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zscore_norm</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
                        <span class="s1">&#39;average&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_average_response</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">condition_start_times</span><span class="p">))</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>

                    <span class="k">elif</span> <span class="p">(</span><span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                          <span class="ow">and</span> <span class="n">norm</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">norm_method</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">norm_method</span><span class="p">[</span><span class="n">norm</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">_UnrecognizedNorm</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Normalization method is not recognized,</span><span class="se">\</span>
<span class="s2">                            please choose from the following:</span><span class="se">\</span>
<span class="s2">                            </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">norm_method</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

                <span class="c1"># fill the population dictionary</span>
                <span class="k">if</span> <span class="n">cluster_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">population</span><span class="p">:</span>
                    <span class="n">population</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">population</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># append condition ids to the conditions column</span>
            <span class="n">cond_col</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">condition</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

            <span class="c1"># append condition parameters</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters_matched</span><span class="p">:</span>
                <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">condition</span> <span class="o">==</span> <span class="n">condition</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">)</span>
                <span class="n">param_col</span> <span class="o">+=</span> <span class="p">[</span><span class="n">params</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="c1"># Rearrange the dataframe</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters_matched</span><span class="p">:</span>

            <span class="c1"># Make the population &amp; stimulus parameters dataframes</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>
            <span class="n">param_col</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">param_col</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">)</span>

            <span class="c1"># Retrieve their column labels</span>
            <span class="n">pcol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">pacol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">param_col</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># Add the condition id column &amp; the stimulus parameters columns</span>
            <span class="n">population</span><span class="p">[</span><span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_col</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">population</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">param_col</span><span class="p">)</span>

            <span class="c1"># Rearrange column order</span>
            <span class="n">new_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pacol</span> <span class="o">+</span> <span class="n">pcol</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">population</span><span class="p">[</span><span class="n">new_columns</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Make the population dataframe</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>

            <span class="c1"># Retrieve its column labels</span>
            <span class="n">pcol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># Add the condition id column</span>
            <span class="n">population</span><span class="p">[</span><span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_col</span>

            <span class="c1"># Rearrange column order</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">population</span><span class="p">[[</span><span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">pcol</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">population</span>       

    <span class="k">def</span> <span class="nf">_pr_stimcols</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">include_units</span><span class="p">,</span> 
            <span class="n">stim_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">thresh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Please provide a response boundary threshhold as a tuple (ex: (-50,500))&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thresh_min</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">thresh_max</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span>

        <span class="k">if</span> <span class="n">stim_condition</span> <span class="ow">is</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">stim_condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span><span class="p">)</span>

        <span class="n">population</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">unit_col</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="n">include_units</span><span class="p">:</span>
            <span class="n">unit_spike_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_data</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">][</span><span class="s1">&#39;rel_spike_time&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">stim_condition</span><span class="p">:</span>
                <span class="n">condition_start_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">condition_times</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>

                <span class="c1"># Raster</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raster</span><span class="p">(</span>
                    <span class="n">condition_start_times</span><span class="p">,</span> 
                    <span class="n">unit_spike_times</span><span class="p">,</span>
                    <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">)</span>

                <span class="c1"># Raster to histogram </span>
                <span class="n">h</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> 
                    <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">thresh_min</span><span class="p">,</span><span class="n">thresh_max</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Nonresponsive unit histogram</span>
                <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">h</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>

                <span class="c1"># Normalize the response</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                    <span class="n">norm_method</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;minmax&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minmax_norm</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
                        <span class="s1">&#39;zscore&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zscore_norm</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
                        <span class="s1">&#39;average&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_average_response</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">condition_start_times</span><span class="p">))</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>

                    <span class="k">elif</span> <span class="p">(</span><span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                          <span class="ow">and</span> <span class="n">norm</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">norm_method</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">norm_method</span><span class="p">[</span><span class="n">norm</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">_UnrecognizedNorm</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Normalization method is not recognized,</span><span class="se">\</span>
<span class="s2">                            please choose from the following:</span><span class="se">\</span>
<span class="s2">                            </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">norm_method</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

                <span class="c1"># fill the population dictionary</span>
                <span class="k">if</span> <span class="n">condition</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">population</span><span class="p">:</span>
                    <span class="n">population</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">condition</span><span class="p">)]</span> <span class="o">=</span> <span class="n">h</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">population</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">condition</span><span class="p">)],</span> <span class="n">h</span><span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># append condition ids to the conditions column</span>
            <span class="n">unit_col</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="c1"># Rearrange the dataframe</span>
        <span class="n">population</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>
        <span class="n">pcol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">population</span><span class="p">[</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit_col</span>
        <span class="n">population</span> <span class="o">=</span> <span class="n">population</span><span class="p">[[</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">pcol</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">population</span>       

    <span class="k">def</span> <span class="nf">population_response</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">include_units</span><span class="p">,</span>  <span class="c1"># Units to include in the dataframe</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Stimulus condition(s) to include in the dataframe</span>
            <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span>  <span class="c1"># Set column label arrangement</span>
            <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Bounding threshold around the stimulus onset at t = 0 - pass as a tuple</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span>  <span class="c1"># Normalization method - choose from: &#39;minmax&#39;, &#39;zscore&#39;, or &#39;average&#39;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dataframe of the population response PSTH.</span>
<span class="sd">        By default, each column label represents the</span>
<span class="sd">        included units. A single column identifies</span>
<span class="sd">        the stimulus condition at each row. Each row is the</span>
<span class="sd">        average response at each time step.</span>

<span class="sd">        Setting columns = &quot;stimulus_condition&quot; will</span>
<span class="sd">        return a data frame where each column label</span>
<span class="sd">        represents a stimulus condition. A single</span>
<span class="sd">        column identifes the included unit at each row.</span>
<span class="sd">        Each row is the average response at each time step.</span>

<span class="sd">        Args:</span>

<span class="sd">        - include_units: Units to include in the dataframe - pass as a 1d array or list like object.</span>
<span class="sd">        - stim_condition: Stimulus condition(s) to include in the dataframe - </span>
<span class="sd">          pass a list of condition ids or &#39;all&#39; to include all conditions.</span>
<span class="sd">        - columns: Set column label arrangement - pass either &#39;cluster_id&#39; or &#39;stimulus_condition&#39;. </span>
<span class="sd">          Default argument is &#39;stimulus_condition&#39;.</span>
<span class="sd">        - thresh: Bounding threshold around the stimulus onset at t = 0 - pass as a tuple.</span>
<span class="sd">        - norm: Normalization method - pass either &#39;minmax&#39;, &#39;zscore&#39;, or &#39;average&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Case checks:</span>
        <span class="k">if</span> <span class="n">stim_condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_NoStimulusCondition</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">stim_condition</span> <span class="ow">is</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">stim_condition</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span><span class="p">)):</span> <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_UnrecognizedStimulusCondition</span><span class="p">()</span>

        <span class="n">col_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span> <span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span> 
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col_formats</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_UnrecognizedColumnsInput</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">columns_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="k">elif</span> <span class="n">columns</span> <span class="o">==</span> <span class="s1">&#39;cluster_id&#39;</span><span class="p">:</span>
            <span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pr_unitcols</span><span class="p">(</span>
            <span class="n">include_units</span><span class="p">,</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="n">stim_condition</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">columns</span> <span class="o">==</span> <span class="s1">&#39;stimulus_condition&#39;</span><span class="p">:</span>
            <span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pr_stimcols</span><span class="p">(</span>
            <span class="n">include_units</span><span class="p">,</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="n">stim_condition</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">population</span>
                    
    <span class="k">def</span> <span class="nf">_stim_frame_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="n">frame_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="p">)):</span>
            <span class="n">con</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_grating</span><span class="p">(</span>
                <span class="n">sf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="s1">&#39;Spatial Freq&#39;</span><span class="p">]),</span>
                <span class="n">ori</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="s1">&#39;Orientation&#39;</span><span class="p">]),</span>
                <span class="n">ph</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">])</span><span class="o">*</span><span class="mi">360</span><span class="p">,</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span><span class="p">,</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="p">,</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="p">)</span>

            <span class="n">frame_map</span><span class="p">[</span><span class="n">con</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">frame_map</span> <span class="o">=</span> <span class="n">frame_map</span>

    <span class="k">def</span> <span class="nf">_stim_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stim_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">load_project</span><span class="p">(</span><span class="n">ephys_toolkit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the load_project class with a full path to the</span>
<span class="sd">    directory containing the project files.</span>
<span class="sd">    </span>
<span class="sd">    The .workbook attribute contains a list of dictionaries</span>
<span class="sd">    with the following structure:</span>
<span class="sd">    </span>

<span class="sd">      </span>
<span class="sd">          {</span>
<span class="sd">          </span>
<span class="sd">              &#39;section_id&#39;: int,</span>
<span class="sd">              </span>
<span class="sd">              &#39;spike_sorting_metrics&#39;: dataframe,</span>
<span class="sd">              </span>
<span class="sd">              &#39;blocks&#39;: [</span>
<span class="sd">              </span>
<span class="sd">                  {&#39;block_id&#39;: int, &#39;experiment&#39;, experiment object},</span>
<span class="sd">                  </span>
<span class="sd">                  ]</span>
<span class="sd">                  </span>
<span class="sd">          },</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">    </span>
<span class="sd">    - project_path: Path to the directory containing the project files.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_path</span><span class="p">):</span>
        <span class="n">ephys_toolkit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppath</span> <span class="o">=</span> <span class="n">project_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_project_workbook</span><span class="p">()</span>

    <span class="c1"># generate the workbook of project data</span>
    <span class="k">def</span> <span class="nf">_init_project_workbook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">explorer</span> <span class="o">=</span> <span class="n">path_explorer</span><span class="p">()</span>

        <span class="c1"># find and sort spike files</span>
        <span class="n">spike_files</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">findext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppath</span><span class="p">,</span> <span class="s1">&#39;.mat&#39;</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="s1">&#39;firings&#39;</span><span class="p">)</span>
        <span class="n">spike_files</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;BLK(\d{1,})&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># find and sort stim files</span>
        <span class="n">stim_files</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">findext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppath</span><span class="p">,</span> <span class="s1">&#39;.mat&#39;</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="s1">&#39;stimulusData&#39;</span><span class="p">)</span>
        <span class="n">stim_files</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;BLK(\d{1,})&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
        
        <span class="c1"># find and sort log files</span>
        <span class="n">log_files</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">findext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppath</span><span class="p">,</span> <span class="s1">&#39;.log&#39;</span><span class="p">)</span>
        <span class="n">log_files</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;BLK(\d{1,})&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
        
        <span class="c1"># count how many log files are in the data folder</span>
        <span class="n">log_diff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_files</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">log_files</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">log_diff</span><span class="p">):</span>
            <span class="n">log_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># zip matching blocks</span>
        <span class="n">matched_block_files</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spike_files</span><span class="p">,</span> <span class="n">stim_files</span><span class="p">,</span> <span class="n">log_files</span><span class="p">)</span>

        <span class="c1"># find metrics files</span>
        <span class="n">metrics_files</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">findext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppath</span><span class="p">,</span> <span class="s1">&#39;.json&#39;</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="s1">&#39;metrics_isolation&#39;</span><span class="p">)</span>

        <span class="c1">################################################################################</span>

        <span class="c1"># compile the workbook</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># compile spike sorting metrics first</span>
        <span class="k">for</span> <span class="n">metrics_file</span> <span class="ow">in</span> <span class="n">metrics_files</span><span class="p">:</span>
            <span class="n">section_parent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Section_(\d{1,})&#39;</span><span class="p">,</span> <span class="n">metrics_file</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_sorting_metrics</span><span class="p">(</span><span class="n">metrics_file</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s1">&#39;section_id&#39;</span><span class="p">:</span> <span class="n">section_parent</span><span class="p">,</span>
                    <span class="s1">&#39;spike_sorting_metrics&#39;</span><span class="p">:</span> <span class="n">df</span><span class="p">,</span>
                    <span class="s1">&#39;blocks&#39;</span><span class="p">:</span> <span class="p">[]</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="c1"># match experiment (block) objects to section</span>
        <span class="k">for</span> <span class="n">matched_files</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">matched_block_files</span><span class="p">):</span>
            <span class="c1"># a regex to get the experiment identity</span>
            <span class="n">ex_r</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;[A-Z]</span><span class="si">{2}</span><span class="s1">_M\d+_Section_\d+_BLK\d+&#39;</span> 
            <span class="n">experiment_id</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">ex_r</span><span class="p">,</span> <span class="n">matched_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="n">section_child</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Section_(\d{1,})&#39;</span><span class="p">,</span> <span class="n">matched_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;BLK(\d{1,})&#39;</span><span class="p">,</span> <span class="n">matched_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

            <span class="n">experiment</span> <span class="o">=</span> <span class="n">load_experiment</span><span class="p">(</span><span class="o">*</span><span class="n">matched_files</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="p">[</span><span class="n">section_child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;blocks&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;block_id&#39;</span><span class="p">:</span> <span class="n">block</span><span class="p">,</span>
                <span class="s1">&#39;experiment&#39;</span><span class="p">:</span> <span class="n">experiment</span>
            <span class="p">})</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sucessfully loaded </span><span class="si">{</span><span class="n">experiment_id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>


<span class="c1"># Class Errors</span>
<span class="k">class</span> <span class="nc">_UnrecognizedNorm</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception raised for unrecognized user input</span>
<span class="sd">    for array normalization.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_NoStimulusCondition</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception raised for no user input in the</span>
<span class="sd">    stim_condition argument in the </span>
<span class="sd">    self.population_response method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Please pass a stimulus condition or enter &#39;all&#39; to generate </span>
<span class="s2">        a joint condition population response matrix.</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_UnrecognizedStimulusCondition</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception raised for invalid user input in the</span>
<span class="sd">    stim_condition argument in the </span>
<span class="sd">    self.population_response method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        The stimulus condition does not exist within this experiment.</span>
<span class="s2">        Please enter a valid stimulus condition.</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_UnrecognizedColumnsInput</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception raised for invalid user input in the</span>
<span class="sd">    columns argument in the </span>
<span class="sd">    self.population_response method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Invalid input for &#39;columns&#39;. Please select one of: </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
</pre></div>

        </details>

            </section>
                <section id="ephys_toolkit">
                                <div class="attr class">
        <a class="headerlink" href="#ephys_toolkit">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">ephys_toolkit</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ephys_toolkit</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SAMPLING_RATE</span> <span class="o">=</span> <span class="mi">20000</span>

    <span class="k">def</span> <span class="nf">_bin_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="n">bin_size</span> <span class="o">**</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numerator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SAMPLING_RATE</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span>

        <span class="k">return</span> <span class="n">events</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">numerator</span>

    <span class="k">def</span> <span class="nf">_minmax_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize an array with minmax normalization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">array</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">array</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_zscore_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize an array with z score normalization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">zscore</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_average_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">stim_reps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the average frequency of a unit&#39;s response</span>
<span class="sd">        across stimulus repeats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">array</span> <span class="o">/</span> <span class="n">stim_reps</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span>
    
    <span class="k">def</span> <span class="nf">static_grating</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">windowSizeX_Pixel</span><span class="p">,</span> <span class="n">windowSizeY_Pixel</span><span class="p">,</span> <span class="c1"># size of the stimulus window in pixels</span>
            <span class="n">windowSizeX_Visual</span><span class="p">,</span> <span class="n">windowSizeY_Visual</span><span class="p">,</span> <span class="c1"># size of the stimulus window in degrees</span>
            <span class="n">spatialFrequency</span><span class="p">,</span> <span class="c1"># spatial frequency in cpd</span>
            <span class="n">ang</span><span class="p">,</span> <span class="c1"># orientation angle of the grating in degrees</span>
            <span class="n">phi</span><span class="p">,</span> <span class="c1"># phase of the grating in degrees</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># dimater of the circular patch in degrees</span>
    <span class="p">):</span>    
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a matrix of pixel intensities   </span>
<span class="sd">        representing a static grating stimulus</span>
<span class="sd">        with the given parameters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - windowSizeX_Pixel: Horizontal size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeY_Pixel: Vertical size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeX_Visual: Horizontal size of the stimulus screen in degrees.</span>
<span class="sd">        - windowSizeY_Visual: Vertical size of the stimulus screen in degrees.</span>
<span class="sd">        - spatialFrequency: Spatial frequency in cycles per degre (cpd).</span>
<span class="sd">        - ang: Orientation angle of the grating in degrees.</span>
<span class="sd">        - phi: Phase of the grating in degrees</span>
<span class="sd">        - diameter: Dimater of the circular patch in degrees. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="p">((</span><span class="n">windowSizeX_Pixel</span> <span class="o">&lt;=</span><span class="mi">10</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">windowSizeX_Pixel</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;windowSizeX_Pixel must be greater than ten and even&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">windowSizeY_Pixel</span> <span class="o">&lt;=</span><span class="mi">10</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">windowSizeY_Pixel</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;windowSizeY_Pixel must be greater than ten and even&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">windowSizeX_Pixel</span><span class="o">/</span><span class="n">windowSizeY_Pixel</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> 
            <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">windowSizeX_Visual</span><span class="o">/</span><span class="n">windowSizeY_Visual</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The ratio of X and Y for Pixel and Visual are different!&#39;</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">spatialFrequency</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">error</span><span class="p">(</span><span class="s1">&#39;spatialFrequency less than zero&#39;</span><span class="p">)</span>

        <span class="c1"># x, y </span>
        <span class="n">x_center</span> <span class="o">=</span> <span class="n">windowSizeX_Pixel</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">y_center</span> <span class="o">=</span> <span class="n">windowSizeY_Pixel</span><span class="o">/</span><span class="mi">2</span>

        <span class="n">x_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">x_center</span><span class="p">,</span> <span class="n">x_center</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">y_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">y_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span><span class="n">y_range</span><span class="p">)</span>

        <span class="c1"># theta</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ang</span><span class="p">);</span>
        <span class="n">xyTheta</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>

        <span class="c1"># Spatial Frenquency</span>
        <span class="n">degreePerPixel</span> <span class="o">=</span> <span class="n">windowSizeX_Visual</span> <span class="o">/</span> <span class="n">windowSizeX_Pixel</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">spatialFrequency</span>  <span class="o">*</span> <span class="n">degreePerPixel</span> <span class="c1"># cycles / pixel</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sf</span> <span class="c1"># radian / pixel</span>

        <span class="c1"># contrast</span>
        <span class="n">pixelIntensity</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sw</span> <span class="o">*</span> <span class="n">xyTheta</span> <span class="o">-</span> <span class="n">phi</span><span class="p">))</span> <span class="c1"># range: -1 to 1</span>

        <span class="c1"># round image</span>
        <span class="k">if</span> <span class="n">diameter</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">/</span> <span class="n">degreePerPixel</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">diameter</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
            <span class="n">c_mask</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
            <span class="n">pixelIntensity</span> <span class="o">=</span> <span class="n">pixelIntensity</span><span class="o">*</span><span class="n">c_mask</span> 

        <span class="k">return</span> <span class="n">pixelIntensity</span>

    <span class="k">def</span> <span class="nf">drifting_grating</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">windowSizeX_Pixel</span><span class="p">,</span> <span class="n">windowSizeY_Pixel</span><span class="p">,</span> <span class="c1"># size of the stimulus window in pixels</span>
            <span class="n">windowSizeX_Visual</span><span class="p">,</span> <span class="n">windowSizeY_Visual</span><span class="p">,</span> <span class="c1"># size of the stimulus window in degrees</span>
            <span class="n">tf</span><span class="p">,</span>  <span class="c1"># Temporal frequency - pass as an integer or floating point value</span>
            <span class="n">dt</span><span class="p">,</span>  <span class="c1"># Time step value - pass as a floating point value</span>
            <span class="n">t</span><span class="p">,</span>  <span class="c1"># Total duration of the stimulus - pass as an int or float of the appropriate time unit</span>
            <span class="n">spatialFrequency</span><span class="p">,</span> <span class="c1"># spatial frequency in cpd</span>
            <span class="n">ang</span><span class="p">,</span> <span class="c1"># orientation angle of the grating in degrees</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># dimater of the circular patch in degrees</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of matricies representing</span>
<span class="sd">        frames of a drifitng grating stimulus.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        - windowSizeX_Pixel: Horizontal size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeY_Pixel: Vertical size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeX_Visual: Horizontal size of the stimulus screen in degrees.</span>
<span class="sd">        - windowSizeY_Visual: Vertical size of the stimulus screen in degrees.    </span>
<span class="sd">        - tf: Temporal frequency - pass as an integer or floating point value.</span>
<span class="sd">        - dt: Time step value - pass as a floating point value.</span>
<span class="sd">        - t: Total duration of the stimulus - pass as an int or float of the appropriate time unit.</span>
<span class="sd">        - spatialFrequency: Spatial frequency in cycles per degre (cpd).</span>
<span class="sd">        - ang: Orientation angle of the grating in degrees.</span>
<span class="sd">        - diameter: Dimater of the circular patch in degrees. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tensor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deg_step</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="mi">360</span> <span class="o">*</span> <span class="n">tf</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_grating</span><span class="p">(</span>
                <span class="n">windowSizeX_Pixel</span><span class="p">,</span> <span class="n">windowSizeY_Pixel</span><span class="p">,</span> 
                <span class="n">windowSizeX_Visual</span><span class="p">,</span> <span class="n">windowSizeY_Visual</span><span class="p">,</span> 
                <span class="n">spatialFrequency</span><span class="p">,</span>
                <span class="n">ang</span><span class="p">,</span>
                <span class="n">phi</span><span class="p">,</span>
                <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span>
            <span class="p">)</span> 
            <span class="n">tensor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">sf</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">ori</span><span class="p">,</span> <span class="n">phase</span><span class="p">])</span>
            <span class="n">phi</span> <span class="o">+=</span> <span class="n">deg_step</span>

        <span class="k">return</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">_discrete_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        

        <span class="n">m</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="o">&lt;</span> <span class="p">((</span><span class="n">radius</span> <span class="o">/</span> <span class="mi">360</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)):</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">_gaussian_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">sigma</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">radius</span> <span class="o">/</span> <span class="mi">360</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">d</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">spike_sorting_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dataframe with the spike sorting metrics</span>
<span class="sd">        of a given recording section.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - file_path: Path to the spike sorting metrics file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">sorting_file</span><span class="p">:</span>
            <span class="n">sorting_info</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sorting_file</span><span class="p">)</span>

        <span class="n">spike_sorting_data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># [cluster[&#39;label&#39;] for cluster in sorting_info[&#39;clusters&#39;]],</span>
            <span class="p">[</span><span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;metrics&#39;</span><span class="p">][</span><span class="s1">&#39;isolation&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">sorting_info</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;metrics&#39;</span><span class="p">][</span><span class="s1">&#39;noise_overlap&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">sorting_info</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]]</span>
        <span class="p">]</span>

        <span class="n">ss_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spike_sorting_data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">ss_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># &#39;cluster&#39;, </span>
            <span class="s1">&#39;isolation&#39;</span><span class="p">,</span> <span class="s1">&#39;noise_overlap&#39;</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">ss_df</span>

    <span class="c1"># functions to make concatenated across trial and non concatenated across trial rasters</span>
    <span class="k">def</span> <span class="nf">_concatenated_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stims</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thresh</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spikes</span> <span class="o">-</span> <span class="n">st</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stims</span><span class="p">])</span>
            <span class="n">raster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spikes</span> <span class="o">-</span> <span class="n">st</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stims</span><span class="p">])</span>
            <span class="n">ti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">raster</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">ti</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">raster</span>

    <span class="k">def</span> <span class="nf">_unconcatenated_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stims</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thresh</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">rasters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spikes</span> <span class="o">-</span> <span class="n">st</span> <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">stims</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rasters</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">st</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stims</span><span class="p">):</span>  <span class="c1"># enumerate to make an initial array then vstack</span>
                <span class="n">unthreshed</span> <span class="o">=</span> <span class="n">spikes</span> <span class="o">-</span> <span class="n">st</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">unthreshed</span> <span class="o">&lt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unthreshed</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">rasters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">unthreshed</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">rasters</span>

    <span class="k">def</span> <span class="nf">raster</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">stims</span><span class="p">,</span>  <span class="c1"># Array of stimulus onset times</span>
            <span class="n">spikes</span><span class="p">,</span>  <span class="c1"># Array of spike onset times</span>
            <span class="n">thresh</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span>  <span class="c1"># Bounding threshold around the stimulus onset at t = 0 - pass as a tuple</span>
            <span class="n">concatenate</span><span class="o">=</span><span class="kc">True</span>  <span class="c1"># Concatenate rasters across trials - pass False to return unconcatenated rasters</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an array representing a raster of spike times centered </span>
<span class="sd">        around the onset times of a given stimulus.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - stims: Array of stimulus onset times.</span>
<span class="sd">        - spikes: Array of spike onset times.</span>
<span class="sd">        - thresh: Bounding threshold around the stimulus onset at t = 0 - pass as a tuple.</span>
<span class="sd">        - concatenate: Concatenate rasters across trials; pass False to return unconcatenated rasters.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">concatenate</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenated_raster</span><span class="p">(</span><span class="n">stims</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unconcatenated_raster</span><span class="p">(</span><span class="n">stims</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">avg_across_param</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">pop_resp</span><span class="p">,</span> <span class="c1"># this df must have cluster ids as columns</span>
            <span class="n">col_param</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="c1"># parameter whose values are to be shown in the columns</span>
            <span class="n">avg_param</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="c1"># parameters to average across</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dataframe showing responses as a function one parameter while averaging</span>
<span class="sd">        over the other parameters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        - pop_resp: A dataframe of the population response in which the columns are units.</span>
<span class="sd">        - col_param: The parameter to show in the columns.</span>
<span class="sd">        - avg_param: The parameter(s) to average across.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># groupby the parameter of interest</span>
        <span class="n">gb</span> <span class="o">=</span> <span class="n">pop_resp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_param</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># get an array of the column values and cluster ids</span>
        <span class="n">col_values</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gb</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)]</span>

        <span class="c1"># initialize dictionary for cross parameter averaged data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cluster&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">col_values</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># create the cluster id column</span>
        <span class="k">for</span> <span class="n">unit_id</span> <span class="ow">in</span> <span class="n">units</span><span class="p">:</span>
            <span class="n">unit_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">unit_id</span><span class="p">]</span><span class="o">*</span><span class="mi">500</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">],</span> <span class="n">unit_ids</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># get the number of parameter combos and length of response</span>
        <span class="n">param_combos</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">avg_param</span><span class="p">:</span>
            <span class="n">param_combos</span><span class="o">*=</span><span class="nb">len</span><span class="p">(</span><span class="n">pop_resp</span><span class="p">[</span><span class="n">param</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">resp_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_resp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pop_resp</span><span class="o">.</span><span class="n">stimulus_condition</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>

         <span class="c1"># create the firing rate value columns</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">col_values</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">unit_id</span> <span class="ow">in</span> <span class="n">units</span><span class="p">:</span>
                    <span class="n">cc_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gb</span><span class="p">[</span><span class="n">unit_id</span><span class="p">][</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">param_combos</span><span class="p">,</span><span class="n">resp_len</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">cc_avg</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                        Failed to reshape response array. </span>
<span class="s2">                        Make sure col_param is not repeated</span>
<span class="s2">                        in avg_param.</span>
<span class="s2">                        &quot;&quot;&quot;</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
</pre></div>

        </details>

    

                            <div id="ephys_toolkit.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ephys_toolkit.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">ephys_toolkit</span><span class="signature">()</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SAMPLING_RATE</span> <span class="o">=</span> <span class="mi">20000</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="ephys_toolkit.static_grating" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ephys_toolkit.static_grating">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">static_grating</span><span class="signature">(
    self,
    windowSizeX_Pixel,
    windowSizeY_Pixel,
    windowSizeX_Visual,
    windowSizeY_Visual,
    spatialFrequency,
    ang,
    phi,
    diameter=None
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">static_grating</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">windowSizeX_Pixel</span><span class="p">,</span> <span class="n">windowSizeY_Pixel</span><span class="p">,</span> <span class="c1"># size of the stimulus window in pixels</span>
            <span class="n">windowSizeX_Visual</span><span class="p">,</span> <span class="n">windowSizeY_Visual</span><span class="p">,</span> <span class="c1"># size of the stimulus window in degrees</span>
            <span class="n">spatialFrequency</span><span class="p">,</span> <span class="c1"># spatial frequency in cpd</span>
            <span class="n">ang</span><span class="p">,</span> <span class="c1"># orientation angle of the grating in degrees</span>
            <span class="n">phi</span><span class="p">,</span> <span class="c1"># phase of the grating in degrees</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># dimater of the circular patch in degrees</span>
    <span class="p">):</span>    
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a matrix of pixel intensities   </span>
<span class="sd">        representing a static grating stimulus</span>
<span class="sd">        with the given parameters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - windowSizeX_Pixel: Horizontal size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeY_Pixel: Vertical size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeX_Visual: Horizontal size of the stimulus screen in degrees.</span>
<span class="sd">        - windowSizeY_Visual: Vertical size of the stimulus screen in degrees.</span>
<span class="sd">        - spatialFrequency: Spatial frequency in cycles per degre (cpd).</span>
<span class="sd">        - ang: Orientation angle of the grating in degrees.</span>
<span class="sd">        - phi: Phase of the grating in degrees</span>
<span class="sd">        - diameter: Dimater of the circular patch in degrees. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="p">((</span><span class="n">windowSizeX_Pixel</span> <span class="o">&lt;=</span><span class="mi">10</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">windowSizeX_Pixel</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;windowSizeX_Pixel must be greater than ten and even&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">windowSizeY_Pixel</span> <span class="o">&lt;=</span><span class="mi">10</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">windowSizeY_Pixel</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;windowSizeY_Pixel must be greater than ten and even&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">windowSizeX_Pixel</span><span class="o">/</span><span class="n">windowSizeY_Pixel</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> 
            <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">windowSizeX_Visual</span><span class="o">/</span><span class="n">windowSizeY_Visual</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The ratio of X and Y for Pixel and Visual are different!&#39;</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">spatialFrequency</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">error</span><span class="p">(</span><span class="s1">&#39;spatialFrequency less than zero&#39;</span><span class="p">)</span>

        <span class="c1"># x, y </span>
        <span class="n">x_center</span> <span class="o">=</span> <span class="n">windowSizeX_Pixel</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">y_center</span> <span class="o">=</span> <span class="n">windowSizeY_Pixel</span><span class="o">/</span><span class="mi">2</span>

        <span class="n">x_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">x_center</span><span class="p">,</span> <span class="n">x_center</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">y_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">y_center</span><span class="p">,</span> <span class="n">y_center</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span><span class="n">y_range</span><span class="p">)</span>

        <span class="c1"># theta</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ang</span><span class="p">);</span>
        <span class="n">xyTheta</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>

        <span class="c1"># Spatial Frenquency</span>
        <span class="n">degreePerPixel</span> <span class="o">=</span> <span class="n">windowSizeX_Visual</span> <span class="o">/</span> <span class="n">windowSizeX_Pixel</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="n">spatialFrequency</span>  <span class="o">*</span> <span class="n">degreePerPixel</span> <span class="c1"># cycles / pixel</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sf</span> <span class="c1"># radian / pixel</span>

        <span class="c1"># contrast</span>
        <span class="n">pixelIntensity</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">sw</span> <span class="o">*</span> <span class="n">xyTheta</span> <span class="o">-</span> <span class="n">phi</span><span class="p">))</span> <span class="c1"># range: -1 to 1</span>

        <span class="c1"># round image</span>
        <span class="k">if</span> <span class="n">diameter</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span> <span class="o">/</span> <span class="n">degreePerPixel</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">diameter</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
            <span class="n">c_mask</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
            <span class="n">pixelIntensity</span> <span class="o">=</span> <span class="n">pixelIntensity</span><span class="o">*</span><span class="n">c_mask</span> 

        <span class="k">return</span> <span class="n">pixelIntensity</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generate a matrix of pixel intensities <br />
representing a static grating stimulus
with the given parameters.</p>

<p>Args:</p>

<ul>
<li>windowSizeX_Pixel: Horizontal size of the stimulus screen in pixels.</li>
<li>windowSizeY_Pixel: Vertical size of the stimulus screen in pixels.</li>
<li>windowSizeX_Visual: Horizontal size of the stimulus screen in degrees.</li>
<li>windowSizeY_Visual: Vertical size of the stimulus screen in degrees.</li>
<li>spatialFrequency: Spatial frequency in cycles per degre (cpd).</li>
<li>ang: Orientation angle of the grating in degrees.</li>
<li>phi: Phase of the grating in degrees</li>
<li>diameter: Dimater of the circular patch in degrees.</li>
</ul>
</div>


                            </div>
                            <div id="ephys_toolkit.drifting_grating" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ephys_toolkit.drifting_grating">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">drifting_grating</span><span class="signature">(
    self,
    windowSizeX_Pixel,
    windowSizeY_Pixel,
    windowSizeX_Visual,
    windowSizeY_Visual,
    tf,
    dt,
    t,
    spatialFrequency,
    ang,
    diameter=None
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">drifting_grating</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">windowSizeX_Pixel</span><span class="p">,</span> <span class="n">windowSizeY_Pixel</span><span class="p">,</span> <span class="c1"># size of the stimulus window in pixels</span>
            <span class="n">windowSizeX_Visual</span><span class="p">,</span> <span class="n">windowSizeY_Visual</span><span class="p">,</span> <span class="c1"># size of the stimulus window in degrees</span>
            <span class="n">tf</span><span class="p">,</span>  <span class="c1"># Temporal frequency - pass as an integer or floating point value</span>
            <span class="n">dt</span><span class="p">,</span>  <span class="c1"># Time step value - pass as a floating point value</span>
            <span class="n">t</span><span class="p">,</span>  <span class="c1"># Total duration of the stimulus - pass as an int or float of the appropriate time unit</span>
            <span class="n">spatialFrequency</span><span class="p">,</span> <span class="c1"># spatial frequency in cpd</span>
            <span class="n">ang</span><span class="p">,</span> <span class="c1"># orientation angle of the grating in degrees</span>
            <span class="n">diameter</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># dimater of the circular patch in degrees</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of matricies representing</span>
<span class="sd">        frames of a drifitng grating stimulus.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        - windowSizeX_Pixel: Horizontal size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeY_Pixel: Vertical size of the stimulus screen in pixels.</span>
<span class="sd">        - windowSizeX_Visual: Horizontal size of the stimulus screen in degrees.</span>
<span class="sd">        - windowSizeY_Visual: Vertical size of the stimulus screen in degrees.    </span>
<span class="sd">        - tf: Temporal frequency - pass as an integer or floating point value.</span>
<span class="sd">        - dt: Time step value - pass as a floating point value.</span>
<span class="sd">        - t: Total duration of the stimulus - pass as an int or float of the appropriate time unit.</span>
<span class="sd">        - spatialFrequency: Spatial frequency in cycles per degre (cpd).</span>
<span class="sd">        - ang: Orientation angle of the grating in degrees.</span>
<span class="sd">        - diameter: Dimater of the circular patch in degrees. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tensor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deg_step</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="mi">360</span> <span class="o">*</span> <span class="n">tf</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

        <span class="n">phi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_grating</span><span class="p">(</span>
                <span class="n">windowSizeX_Pixel</span><span class="p">,</span> <span class="n">windowSizeY_Pixel</span><span class="p">,</span> 
                <span class="n">windowSizeX_Visual</span><span class="p">,</span> <span class="n">windowSizeY_Visual</span><span class="p">,</span> 
                <span class="n">spatialFrequency</span><span class="p">,</span>
                <span class="n">ang</span><span class="p">,</span>
                <span class="n">phi</span><span class="p">,</span>
                <span class="n">diameter</span> <span class="o">=</span> <span class="n">diameter</span>
            <span class="p">)</span> 
            <span class="n">tensor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">sf</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">ori</span><span class="p">,</span> <span class="n">phase</span><span class="p">])</span>
            <span class="n">phi</span> <span class="o">+=</span> <span class="n">deg_step</span>

        <span class="k">return</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">params</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a list of matricies representing
frames of a drifitng grating stimulus.</p>

<p>Args:</p>

<ul>
<li>windowSizeX_Pixel: Horizontal size of the stimulus screen in pixels.</li>
<li>windowSizeY_Pixel: Vertical size of the stimulus screen in pixels.</li>
<li>windowSizeX_Visual: Horizontal size of the stimulus screen in degrees.</li>
<li>windowSizeY_Visual: Vertical size of the stimulus screen in degrees.    </li>
<li>tf: Temporal frequency - pass as an integer or floating point value.</li>
<li>dt: Time step value - pass as a floating point value.</li>
<li>t: Total duration of the stimulus - pass as an int or float of the appropriate time unit.</li>
<li>spatialFrequency: Spatial frequency in cycles per degre (cpd).</li>
<li>ang: Orientation angle of the grating in degrees.</li>
<li>diameter: Dimater of the circular patch in degrees.</li>
</ul>
</div>


                            </div>
                            <div id="ephys_toolkit.spike_sorting_metrics" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ephys_toolkit.spike_sorting_metrics">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">spike_sorting_metrics</span><span class="signature">(self, file_path)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">spike_sorting_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dataframe with the spike sorting metrics</span>
<span class="sd">        of a given recording section.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - file_path: Path to the spike sorting metrics file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">sorting_file</span><span class="p">:</span>
            <span class="n">sorting_info</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sorting_file</span><span class="p">)</span>

        <span class="n">spike_sorting_data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># [cluster[&#39;label&#39;] for cluster in sorting_info[&#39;clusters&#39;]],</span>
            <span class="p">[</span><span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;metrics&#39;</span><span class="p">][</span><span class="s1">&#39;isolation&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">sorting_info</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">cluster</span><span class="p">[</span><span class="s1">&#39;metrics&#39;</span><span class="p">][</span><span class="s1">&#39;noise_overlap&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">sorting_info</span><span class="p">[</span><span class="s1">&#39;clusters&#39;</span><span class="p">]]</span>
        <span class="p">]</span>

        <span class="n">ss_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spike_sorting_data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">ss_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># &#39;cluster&#39;, </span>
            <span class="s1">&#39;isolation&#39;</span><span class="p">,</span> <span class="s1">&#39;noise_overlap&#39;</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">ss_df</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a dataframe with the spike sorting metrics
of a given recording section.</p>

<p>Args:</p>

<ul>
<li>file_path: Path to the spike sorting metrics file.</li>
</ul>
</div>


                            </div>
                            <div id="ephys_toolkit.raster" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ephys_toolkit.raster">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">raster</span><span class="signature">(self, stims, spikes, thresh=&lt;class &#39;tuple&#39;&gt;, concatenate=True)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">raster</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">stims</span><span class="p">,</span>  <span class="c1"># Array of stimulus onset times</span>
            <span class="n">spikes</span><span class="p">,</span>  <span class="c1"># Array of spike onset times</span>
            <span class="n">thresh</span><span class="o">=</span><span class="nb">tuple</span><span class="p">,</span>  <span class="c1"># Bounding threshold around the stimulus onset at t = 0 - pass as a tuple</span>
            <span class="n">concatenate</span><span class="o">=</span><span class="kc">True</span>  <span class="c1"># Concatenate rasters across trials - pass False to return unconcatenated rasters</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an array representing a raster of spike times centered </span>
<span class="sd">        around the onset times of a given stimulus.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - stims: Array of stimulus onset times.</span>
<span class="sd">        - spikes: Array of spike onset times.</span>
<span class="sd">        - thresh: Bounding threshold around the stimulus onset at t = 0 - pass as a tuple.</span>
<span class="sd">        - concatenate: Concatenate rasters across trials; pass False to return unconcatenated rasters.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">concatenate</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_concatenated_raster</span><span class="p">(</span><span class="n">stims</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unconcatenated_raster</span><span class="p">(</span><span class="n">stims</span><span class="p">,</span> <span class="n">spikes</span><span class="p">,</span> <span class="n">thresh</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns an array representing a raster of spike times centered 
around the onset times of a given stimulus.</p>

<p>Args:</p>

<ul>
<li>stims: Array of stimulus onset times.</li>
<li>spikes: Array of spike onset times.</li>
<li>thresh: Bounding threshold around the stimulus onset at t = 0 - pass as a tuple.</li>
<li>concatenate: Concatenate rasters across trials; pass False to return unconcatenated rasters.</li>
</ul>
</div>


                            </div>
                            <div id="ephys_toolkit.avg_across_param" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ephys_toolkit.avg_across_param">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">avg_across_param</span><span class="signature">(self, pop_resp, col_param: str, avg_param: list)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">avg_across_param</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">pop_resp</span><span class="p">,</span> <span class="c1"># this df must have cluster ids as columns</span>
            <span class="n">col_param</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="c1"># parameter whose values are to be shown in the columns</span>
            <span class="n">avg_param</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="c1"># parameters to average across</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dataframe showing responses as a function one parameter while averaging</span>
<span class="sd">        over the other parameters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        - pop_resp: A dataframe of the population response in which the columns are units.</span>
<span class="sd">        - col_param: The parameter to show in the columns.</span>
<span class="sd">        - avg_param: The parameter(s) to average across.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># groupby the parameter of interest</span>
        <span class="n">gb</span> <span class="o">=</span> <span class="n">pop_resp</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">col_param</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># get an array of the column values and cluster ids</span>
        <span class="n">col_values</span> <span class="o">=</span> <span class="n">gb</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gb</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)]</span>

        <span class="c1"># initialize dictionary for cross parameter averaged data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cluster&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">col_values</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># create the cluster id column</span>
        <span class="k">for</span> <span class="n">unit_id</span> <span class="ow">in</span> <span class="n">units</span><span class="p">:</span>
            <span class="n">unit_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">unit_id</span><span class="p">]</span><span class="o">*</span><span class="mi">500</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">],</span> <span class="n">unit_ids</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># get the number of parameter combos and length of response</span>
        <span class="n">param_combos</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">avg_param</span><span class="p">:</span>
            <span class="n">param_combos</span><span class="o">*=</span><span class="nb">len</span><span class="p">(</span><span class="n">pop_resp</span><span class="p">[</span><span class="n">param</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">resp_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pop_resp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pop_resp</span><span class="o">.</span><span class="n">stimulus_condition</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>

         <span class="c1"># create the firing rate value columns</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">col_values</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">unit_id</span> <span class="ow">in</span> <span class="n">units</span><span class="p">:</span>
                    <span class="n">cc_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gb</span><span class="p">[</span><span class="n">unit_id</span><span class="p">][</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">param_combos</span><span class="p">,</span><span class="n">resp_len</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">cc_avg</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                        Failed to reshape response array. </span>
<span class="s2">                        Make sure col_param is not repeated</span>
<span class="s2">                        in avg_param.</span>
<span class="s2">                        &quot;&quot;&quot;</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a dataframe showing responses as a function one parameter while averaging
over the other parameters.</p>

<p>Args:</p>

<ul>
<li>pop_resp: A dataframe of the population response in which the columns are units.</li>
<li>col_param: The parameter to show in the columns.</li>
<li>avg_param: The parameter(s) to average across.</li>
</ul>
</div>


                            </div>
                </section>
                <section id="load_experiment">
                                <div class="attr class">
        <a class="headerlink" href="#load_experiment">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">load_experiment</span><wbr>(<span class="base"><a href="#ephys_toolkit">ephys_toolkit</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">load_experiment</span><span class="p">(</span><span class="n">ephys_toolkit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an experiment object for a given recording block.</span>
<span class="sd">    Takes the spike data file path as the first argument and the</span>
<span class="sd">    stimulus data file path as the second argument. Initializing</span>
<span class="sd">    an experiment object generates some important class attributes:</span>
<span class="sd">    </span>
<span class="sd">    .stim_data: A pandas dataframe with the stimulus data.</span>
<span class="sd">    </span>
<span class="sd">    .spike_data: A dictionary object with the spiking data</span>
<span class="sd">                 of all the identified clusters.</span>
<span class="sd">                 </span>
<span class="sd">    Args:</span>
<span class="sd">    </span>
<span class="sd">    - spikefile: Path to the spike data file.</span>
<span class="sd">    - stimfile: Path to the stimulus data file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikefile</span><span class="p">,</span> <span class="n">stimfile</span><span class="p">,</span> <span class="n">logfile</span><span class="p">):</span>
        <span class="n">ephys_toolkit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">spikes_mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">spikefile</span><span class="p">)</span>
        <span class="n">stims_mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">stimfile</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spikes</span> <span class="o">=</span> <span class="n">spikes_mat</span><span class="p">[</span><span class="s1">&#39;Data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stims</span> <span class="o">=</span> <span class="n">stims_mat</span><span class="p">[</span><span class="s1">&#39;StimulusData&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logfile</span> <span class="o">=</span> <span class="n">logfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_stim_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_spike_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_time_unit</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters_matched</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span>
            <span class="s1">&#39;stim_condition_ids&#39;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logfile</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_conditions_from_log</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;([A-Z]{1,2}_M\d{1,}_Section_\d{1,}_BLK\d{1,})&#39;</span>
            <span class="n">experiment_id</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">spikefile</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">warn_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            No stimulus log file found for experiment: </span><span class="si">{</span><span class="n">experiment_id</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">            If this experiment has more that 255 stimulus conditions, the stimulus </span>
<span class="s2">            condition IDs will be incorrect in the self.stim_data attribute.</span>
<span class="s2">            &quot;&quot;&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warn_text</span><span class="p">,</span> <span class="n">stacklevel</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1"># Generates the .stim_data attribute.</span>
    <span class="k">def</span> <span class="nf">_init_stim_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">stims_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stims_stops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">stims_condition_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">stim_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">:</span> <span class="n">stims_starts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">:</span> <span class="n">stims_stops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;stim_condition_ids&#39;</span><span class="p">:</span> <span class="n">stims_condition_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">stim_data</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A pandas dataframe with the stimulus data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="c1"># Generates the .spike_data attribute.</span>
    <span class="k">def</span> <span class="nf">_init_spike_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spike_data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="c1"># &#39;cluster_id&#39;:unit[0][0][0],</span>
                <span class="s1">&#39;channel_id&#39;</span><span class="p">:</span> <span class="n">unit</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;spike_index&#39;</span><span class="p">:</span> <span class="n">unit</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;spike_time&#39;</span><span class="p">:</span> <span class="n">unit</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spikes</span>
        <span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary object with the spiking data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
    <span class="k">def</span> <span class="nf">_get_conditions_from_log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logfile</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">stimlog</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

        <span class="n">stimlog</span> <span class="o">=</span> <span class="n">stimlog</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        
        <span class="c1"># extract conditions for log</span>
        <span class="n">r0</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;[Cc]ondition#: *(\d{1,})&#39;</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;[Cc]onditions:(\d{1,} +...*)&#39;</span>
        <span class="n">condition_ids</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">stimlog</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># if the experiment is gratings or checkerboard</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">stimlog</span><span class="p">:</span>
                <span class="n">c_id</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">condition_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">c_id</span><span class="p">))</span>
                
            <span class="k">try</span><span class="p">:</span>  
                <span class="c1"># replace conditions in experiment with conditions from log</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span> <span class="o">=</span> <span class="n">condition_ids</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
            
        <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">stimlog</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="c1"># if the experiment is natural images</span>
            <span class="n">condition_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stimlog</span><span class="p">:</span>
                <span class="n">cindex</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="c1"># index where condition numbers begin</span>
                <span class="n">numbers</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">cindex</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="c1"># remove whitespace at the end</span>
                <span class="n">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="c1"># remove double spaces</span>
                <span class="n">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="c1"># split into a list of conditon numbers</span>
                <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span> <span class="c1"># format str into int</span>
                <span class="n">condition_ids</span> <span class="o">+=</span> <span class="n">numbers</span> <span class="c1">#collect condition ids</span>

            <span class="c1">## This horrible block of code is here because the stimData matlab</span>
            <span class="c1">## file is missing the data the last two stimulus repeats</span>
            <span class="c1">## so it is added manually until the stimData file generation is fixed</span>

            <span class="c1"># difference between consecutive start indicies</span>
            <span class="n">startindex_diff</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                             <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># difference between consecutive stop indicies</span>
            <span class="n">stopindex_diff</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                             <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># difference between consecutive start times</span>
            <span class="n">starttime_diff</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                             <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># difference between consecutive stop times</span>
            <span class="n">stoptime_diff</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                             <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># adding two additional start indicies </span>
            <span class="n">start_ind_fixed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">start_ind_fixed</span> <span class="o">=</span> <span class="n">start_ind_fixed</span> <span class="o">+</span> <span class="p">[</span><span class="n">start_ind_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-+</span><span class="n">startindex_diff</span><span class="p">,</span> 
                                                 <span class="n">start_ind_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">startindex_diff</span><span class="p">]</span>
            <span class="c1"># adding two additional stop indicies </span>
            <span class="n">stop_ind_fixed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">stop_ind_fixed</span> <span class="o">=</span> <span class="n">stop_ind_fixed</span> <span class="o">+</span> <span class="p">[</span><span class="n">stop_ind_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">stopindex_diff</span><span class="p">,</span> 
                                                 <span class="n">stop_ind_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">stopindex_diff</span><span class="p">]</span>

            <span class="c1"># adding two additional start times </span>
            <span class="n">start_time_fixed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">start_time_fixed</span> <span class="o">=</span> <span class="n">start_time_fixed</span> <span class="o">+</span> <span class="p">[</span><span class="n">start_time_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">starttime_diff</span><span class="p">,</span> 
                                                 <span class="n">start_time_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">starttime_diff</span><span class="p">]</span>
            <span class="c1"># adding two additional stop times </span>
            <span class="n">stop_time_fixed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">stop_time_fixed</span> <span class="o">=</span> <span class="n">stop_time_fixed</span> <span class="o">+</span> <span class="p">[</span><span class="n">stop_time_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">stoptime_diff</span><span class="p">,</span> 
                                                 <span class="n">stop_time_fixed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">stoptime_diff</span><span class="p">]</span>

            <span class="c1"># fixed stim data dictionary</span>
            <span class="n">stim_data_fixed</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;stim_condition_ids&#39;</span><span class="p">:</span> <span class="n">condition_ids</span><span class="p">,</span>
                <span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">:</span> <span class="n">start_ind_fixed</span><span class="p">,</span>
                <span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">:</span> <span class="n">stop_ind_fixed</span><span class="p">,</span>
                <span class="s1">&#39;stim_start_times&#39;</span><span class="p">:</span> <span class="n">start_time_fixed</span><span class="p">,</span>
                <span class="s1">&#39;stim_stop_times&#39;</span><span class="p">:</span> <span class="n">stop_time_fixed</span>
            <span class="p">}</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">stim_data_fixed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            
    <span class="k">def</span> <span class="nf">set_time_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the time unit of the relative spike times.</span>
<span class="sd">        Give a bin size relative to 1 second.</span>
<span class="sd">        IE: If you want a 1 ms bin size, enter 0.001;</span>
<span class="sd">        if you want a 10 ms bin size, enter 0.01 etc.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - bin_size: Time unit given relative to 1 second. The default unit is 1ms/0.001s.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_events</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_events</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span>
            <span class="p">[</span><span class="s1">&#39;stim_condition_ids&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_start_times&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_data</span><span class="p">:</span>
            <span class="n">unit</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s1">&#39;rel_spike_time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_events</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span>
                                                   <span class="n">unit</span><span class="p">[</span><span class="s1">&#39;spike_index&#39;</span><span class="p">])</span>
            <span class="p">})</span>

    <span class="k">def</span> <span class="nf">condition_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary object of the start times and</span>
<span class="sd">        stop times of a particular stimulus condition.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        -condition: Condition id for the chosen stimulus condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">condition_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span>
        <span class="p">)</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">condition_stops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span>
        <span class="p">)</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="n">condition_starts</span><span class="p">,</span>
            <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="n">condition_stops</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">match_condition_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a parameters file and alters the .stim_data dataframe</span>
<span class="sd">        to match stimulus condition parameters to their corresponding </span>
<span class="sd">        condition id.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - params_file: Path to the stimulus parameters file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># </span>

        <span class="c1"># regex to get the parameter names + values</span>
        <span class="n">name_identifier</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;Var\d{1,}Val&#39;</span>
        <span class="n">val_identifier</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;var\d{1,}value&#39;</span>

        <span class="c1"># load the parameter file and extract the keys</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">params_file</span><span class="p">)</span>
        <span class="n">param_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="k">if</span> <span class="s1">&#39;fnames&#39;</span> <span class="ow">in</span> <span class="n">param_keys</span><span class="p">:</span> <span class="c1"># if experiment is natural images</span>
            
            <span class="c1"># get the stim file names</span>
            <span class="n">stim_file_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> 
                <span class="n">name</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">params_file</span><span class="p">)[</span><span class="s1">&#39;fnames&#39;</span><span class="p">]</span>
            <span class="p">]</span>
            
            <span class="c1"># make a dictionary for the parameter mapping</span>
            <span class="n">ni_filemap</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;condition&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;filter&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;file&#39;</span><span class="p">:</span> <span class="p">[]</span>
            <span class="p">}</span>
            
            <span class="c1"># match condition to parameters</span>
            <span class="n">freg</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;^[A-Z]{2,3}&#39;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># if condition is even</span>
                    
                    <span class="c1">#append condition &amp; size</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
                    
                    <span class="c1">#append filename</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="n">stim_file_names</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> 
                    
                    <span class="c1">#append filtering condition</span>
                    <span class="n">filt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">freg</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
            
                <span class="k">else</span><span class="p">:</span> <span class="c1"># if condition is odd</span>
                    <span class="c1">#append condition &amp; size</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
                    
                    <span class="c1">#append filename</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="n">stim_file_names</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                    
                    <span class="c1">#append filtering condition</span>
                    <span class="n">filt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">freg</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
                    
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ni_filemap</span><span class="p">)</span> 
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span>
            
            <span class="c1"># get the parameters to insert into the original dataframe</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">condition</span> <span class="o">==</span> <span class="n">cond</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">insert</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">insert</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># insert the parameter values into the original dataframe</span>
            <span class="n">df1</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">insert</span><span class="p">)</span>

            <span class="c1"># reset the stim_data attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="n">df1</span><span class="p">[</span>
                <span class="nb">list</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">)</span>
                <span class="p">]</span>
        
        <span class="k">else</span><span class="p">:</span> <span class="c1"># if experiment is gratings or checkerboard</span>
            <span class="c1"># use regex to get the param names and values</span>
            <span class="n">name_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">param_keys</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">name_identifier</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>
            <span class="n">val_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">param_keys</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">val_identifier</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>

            <span class="c1"># get the condition numbers</span>
            <span class="n">condition_range</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">val_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">condition_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">condition_range</span><span class="p">)]</span>

            <span class="c1"># map conditions to parameter values</span>
            <span class="n">parameter_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;condition&#39;</span><span class="p">:</span> <span class="n">condition_ids</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">name_keys</span><span class="p">)):</span>
                <span class="n">parameter_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">name_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">parameter_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">val_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">parameter_map</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter_values</span>

                <span class="c1"># parameter dataframe + the original stim_data dataframe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">parameter_map</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span>

            <span class="c1"># get the parameters to insert into the original dataframe</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">condition</span> <span class="o">==</span> <span class="n">cond</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">insert</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">insert</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># insert the parameter values into the original dataframe</span>
            <span class="n">df1</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">insert</span><span class="p">)</span>

            <span class="c1"># reset the stim_data attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="n">df1</span><span class="p">[</span>
                <span class="nb">list</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">)</span>
                <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters_matched</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_pr_unitcols</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">include_units</span><span class="p">,</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span> 
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">thresh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Please provide a response boundary threshhold as a tuple (ex: (-50,500))&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thresh_min</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">thresh_max</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span>

        <span class="k">if</span> <span class="n">stim_condition</span> <span class="ow">is</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">stim_condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span>

        <span class="n">population</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cond_col</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">param_col</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">stim_condition</span><span class="p">:</span>
            <span class="n">condition_start_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">condition_times</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">include_units</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">cluster_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                    <span class="n">unit_spike_times</span> <span class="o">=</span> <span class="n">cluster_id</span>
                    <span class="n">cluster_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;n</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
                    
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit_spike_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_data</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">][</span><span class="s1">&#39;rel_spike_time&#39;</span><span class="p">]</span>

                <span class="c1"># Raster</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raster</span><span class="p">(</span>
                    <span class="n">condition_start_times</span><span class="p">,</span> 
                    <span class="n">unit_spike_times</span><span class="p">,</span>
                    <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">)</span>

                <span class="c1"># Raster to histogram </span>
                <span class="n">h</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> 
                    <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">thresh_min</span><span class="p">,</span><span class="n">thresh_max</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Nonresponsive unit histogram</span>
                <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">h</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>

                <span class="c1"># Normalize the response</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                    <span class="n">norm_method</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;minmax&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minmax_norm</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
                        <span class="s1">&#39;zscore&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zscore_norm</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
                        <span class="s1">&#39;average&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_average_response</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">condition_start_times</span><span class="p">))</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>

                    <span class="k">elif</span> <span class="p">(</span><span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                          <span class="ow">and</span> <span class="n">norm</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">norm_method</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">norm_method</span><span class="p">[</span><span class="n">norm</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">_UnrecognizedNorm</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Normalization method is not recognized,</span><span class="se">\</span>
<span class="s2">                            please choose from the following:</span><span class="se">\</span>
<span class="s2">                            </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">norm_method</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

                <span class="c1"># fill the population dictionary</span>
                <span class="k">if</span> <span class="n">cluster_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">population</span><span class="p">:</span>
                    <span class="n">population</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">population</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># append condition ids to the conditions column</span>
            <span class="n">cond_col</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">condition</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

            <span class="c1"># append condition parameters</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters_matched</span><span class="p">:</span>
                <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">condition</span> <span class="o">==</span> <span class="n">condition</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">)</span>
                <span class="n">param_col</span> <span class="o">+=</span> <span class="p">[</span><span class="n">params</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="c1"># Rearrange the dataframe</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters_matched</span><span class="p">:</span>

            <span class="c1"># Make the population &amp; stimulus parameters dataframes</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>
            <span class="n">param_col</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">param_col</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">)</span>

            <span class="c1"># Retrieve their column labels</span>
            <span class="n">pcol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">pacol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">param_col</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># Add the condition id column &amp; the stimulus parameters columns</span>
            <span class="n">population</span><span class="p">[</span><span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_col</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">population</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">param_col</span><span class="p">)</span>

            <span class="c1"># Rearrange column order</span>
            <span class="n">new_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pacol</span> <span class="o">+</span> <span class="n">pcol</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">population</span><span class="p">[</span><span class="n">new_columns</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Make the population dataframe</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>

            <span class="c1"># Retrieve its column labels</span>
            <span class="n">pcol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># Add the condition id column</span>
            <span class="n">population</span><span class="p">[</span><span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_col</span>

            <span class="c1"># Rearrange column order</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">population</span><span class="p">[[</span><span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">pcol</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">population</span>       

    <span class="k">def</span> <span class="nf">_pr_stimcols</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">include_units</span><span class="p">,</span> 
            <span class="n">stim_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">thresh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;Please provide a response boundary threshhold as a tuple (ex: (-50,500))&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">thresh_min</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">thresh_max</span> <span class="o">=</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span>

        <span class="k">if</span> <span class="n">stim_condition</span> <span class="ow">is</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">stim_condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span><span class="p">)</span>

        <span class="n">population</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">unit_col</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="n">include_units</span><span class="p">:</span>
            <span class="n">unit_spike_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_data</span><span class="p">[</span><span class="n">cluster_id</span><span class="p">][</span><span class="s1">&#39;rel_spike_time&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">stim_condition</span><span class="p">:</span>
                <span class="n">condition_start_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">condition_times</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>

                <span class="c1"># Raster</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raster</span><span class="p">(</span>
                    <span class="n">condition_start_times</span><span class="p">,</span> 
                    <span class="n">unit_spike_times</span><span class="p">,</span>
                    <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">)</span>

                <span class="c1"># Raster to histogram </span>
                <span class="n">h</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> 
                    <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">thresh_min</span><span class="p">,</span><span class="n">thresh_max</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Nonresponsive unit histogram</span>
                <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">h</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>

                <span class="c1"># Normalize the response</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
                    <span class="n">norm_method</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;minmax&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minmax_norm</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
                        <span class="s1">&#39;zscore&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zscore_norm</span><span class="p">(</span><span class="n">h</span><span class="p">),</span>
                        <span class="s1">&#39;average&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_average_response</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">condition_start_times</span><span class="p">))</span>
                    <span class="p">}</span>

                    <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>

                    <span class="k">elif</span> <span class="p">(</span><span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                          <span class="ow">and</span> <span class="n">norm</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">norm_method</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">norm_method</span><span class="p">[</span><span class="n">norm</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">_UnrecognizedNorm</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Normalization method is not recognized,</span><span class="se">\</span>
<span class="s2">                            please choose from the following:</span><span class="se">\</span>
<span class="s2">                            </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">norm_method</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>

                <span class="c1"># fill the population dictionary</span>
                <span class="k">if</span> <span class="n">condition</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">population</span><span class="p">:</span>
                    <span class="n">population</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">condition</span><span class="p">)]</span> <span class="o">=</span> <span class="n">h</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">population</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">condition</span><span class="p">)],</span> <span class="n">h</span><span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># append condition ids to the conditions column</span>
            <span class="n">unit_col</span> <span class="o">+=</span> <span class="p">[</span><span class="n">cluster_id</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

        <span class="c1"># Rearrange the dataframe</span>
        <span class="n">population</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>
        <span class="n">pcol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">population</span><span class="p">[</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit_col</span>
        <span class="n">population</span> <span class="o">=</span> <span class="n">population</span><span class="p">[[</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">pcol</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">population</span>       

    <span class="k">def</span> <span class="nf">population_response</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">include_units</span><span class="p">,</span>  <span class="c1"># Units to include in the dataframe</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Stimulus condition(s) to include in the dataframe</span>
            <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span>  <span class="c1"># Set column label arrangement</span>
            <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Bounding threshold around the stimulus onset at t = 0 - pass as a tuple</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span>  <span class="c1"># Normalization method - choose from: &#39;minmax&#39;, &#39;zscore&#39;, or &#39;average&#39;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dataframe of the population response PSTH.</span>
<span class="sd">        By default, each column label represents the</span>
<span class="sd">        included units. A single column identifies</span>
<span class="sd">        the stimulus condition at each row. Each row is the</span>
<span class="sd">        average response at each time step.</span>

<span class="sd">        Setting columns = &quot;stimulus_condition&quot; will</span>
<span class="sd">        return a data frame where each column label</span>
<span class="sd">        represents a stimulus condition. A single</span>
<span class="sd">        column identifes the included unit at each row.</span>
<span class="sd">        Each row is the average response at each time step.</span>

<span class="sd">        Args:</span>

<span class="sd">        - include_units: Units to include in the dataframe - pass as a 1d array or list like object.</span>
<span class="sd">        - stim_condition: Stimulus condition(s) to include in the dataframe - </span>
<span class="sd">          pass a list of condition ids or &#39;all&#39; to include all conditions.</span>
<span class="sd">        - columns: Set column label arrangement - pass either &#39;cluster_id&#39; or &#39;stimulus_condition&#39;. </span>
<span class="sd">          Default argument is &#39;stimulus_condition&#39;.</span>
<span class="sd">        - thresh: Bounding threshold around the stimulus onset at t = 0 - pass as a tuple.</span>
<span class="sd">        - norm: Normalization method - pass either &#39;minmax&#39;, &#39;zscore&#39;, or &#39;average&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Case checks:</span>
        <span class="k">if</span> <span class="n">stim_condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_NoStimulusCondition</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">stim_condition</span> <span class="ow">is</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">stim_condition</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span><span class="p">)):</span> <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_UnrecognizedStimulusCondition</span><span class="p">()</span>

        <span class="n">col_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span> <span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span> 
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col_formats</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_UnrecognizedColumnsInput</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">columns_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="k">elif</span> <span class="n">columns</span> <span class="o">==</span> <span class="s1">&#39;cluster_id&#39;</span><span class="p">:</span>
            <span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pr_unitcols</span><span class="p">(</span>
            <span class="n">include_units</span><span class="p">,</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="n">stim_condition</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">columns</span> <span class="o">==</span> <span class="s1">&#39;stimulus_condition&#39;</span><span class="p">:</span>
            <span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pr_stimcols</span><span class="p">(</span>
            <span class="n">include_units</span><span class="p">,</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="n">stim_condition</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">population</span>
                    
    <span class="k">def</span> <span class="nf">_stim_frame_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="n">frame_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="p">)):</span>
            <span class="n">con</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_grating</span><span class="p">(</span>
                <span class="n">sf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="s1">&#39;Spatial Freq&#39;</span><span class="p">]),</span>
                <span class="n">ori</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="s1">&#39;Orientation&#39;</span><span class="p">]),</span>
                <span class="n">ph</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">])</span><span class="o">*</span><span class="mi">360</span><span class="p">,</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span><span class="p">,</span>
                <span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="p">,</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="p">)</span>

            <span class="n">frame_map</span><span class="p">[</span><span class="n">con</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">frame_map</span> <span class="o">=</span> <span class="n">frame_map</span>

    <span class="k">def</span> <span class="nf">_stim_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stim_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">])</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create an experiment object for a given recording block.
Takes the spike data file path as the first argument and the
stimulus data file path as the second argument. Initializing
an experiment object generates some important class attributes:</p>

<p>.stim_data: A pandas dataframe with the stimulus data.</p>

<p>.spike_data: A dictionary object with the spiking data
             of all the identified clusters.</p>

<p>Args:</p>

<ul>
<li>spikefile: Path to the spike data file.</li>
<li>stimfile: Path to the stimulus data file.</li>
</ul>
</div>


                            <div id="load_experiment.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#load_experiment.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">load_experiment</span><span class="signature">(spikefile, stimfile, logfile)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spikefile</span><span class="p">,</span> <span class="n">stimfile</span><span class="p">,</span> <span class="n">logfile</span><span class="p">):</span>
        <span class="n">ephys_toolkit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">spikes_mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">spikefile</span><span class="p">)</span>
        <span class="n">stims_mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">stimfile</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">spikes</span> <span class="o">=</span> <span class="n">spikes_mat</span><span class="p">[</span><span class="s1">&#39;Data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stims</span> <span class="o">=</span> <span class="n">stims_mat</span><span class="p">[</span><span class="s1">&#39;StimulusData&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logfile</span> <span class="o">=</span> <span class="n">logfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_stim_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_spike_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_time_unit</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters_matched</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span>
            <span class="s1">&#39;stim_condition_ids&#39;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logfile</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_conditions_from_log</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;([A-Z]{1,2}_M\d{1,}_Section_\d{1,}_BLK\d{1,})&#39;</span>
            <span class="n">experiment_id</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">spikefile</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">warn_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            No stimulus log file found for experiment: </span><span class="si">{</span><span class="n">experiment_id</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">            If this experiment has more that 255 stimulus conditions, the stimulus </span>
<span class="s2">            condition IDs will be incorrect in the self.stim_data attribute.</span>
<span class="s2">            &quot;&quot;&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warn_text</span><span class="p">,</span> <span class="n">stacklevel</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="load_experiment.set_time_unit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#load_experiment.set_time_unit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_time_unit</span><span class="signature">(self, bin_size=0.001)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_time_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_size</span><span class="o">=</span><span class="mf">0.001</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the time unit of the relative spike times.</span>
<span class="sd">        Give a bin size relative to 1 second.</span>
<span class="sd">        IE: If you want a 1 ms bin size, enter 0.001;</span>
<span class="sd">        if you want a 10 ms bin size, enter 0.01 etc.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - bin_size: Time unit given relative to 1 second. The default unit is 1ms/0.001s.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_events</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_events</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span><span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="p">[</span>
            <span class="p">[</span><span class="s1">&#39;stim_condition_ids&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_start_indicies&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_stop_indicies&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_start_times&#39;</span><span class="p">,</span>
             <span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_data</span><span class="p">:</span>
            <span class="n">unit</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s1">&#39;rel_spike_time&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_events</span><span class="p">(</span><span class="n">bin_size</span><span class="p">,</span>
                                                   <span class="n">unit</span><span class="p">[</span><span class="s1">&#39;spike_index&#39;</span><span class="p">])</span>
            <span class="p">})</span>
</pre></div>

        </details>

            <div class="docstring"><p>Change the time unit of the relative spike times.
Give a bin size relative to 1 second.
IE: If you want a 1 ms bin size, enter 0.001;
if you want a 10 ms bin size, enter 0.01 etc.</p>

<p>Args:</p>

<ul>
<li>bin_size: Time unit given relative to 1 second. The default unit is 1ms/0.001s.</li>
</ul>
</div>


                            </div>
                            <div id="load_experiment.condition_times" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#load_experiment.condition_times">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">condition_times</span><span class="signature">(self, condition)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">condition_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary object of the start times and</span>
<span class="sd">        stop times of a particular stimulus condition.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        -condition: Condition id for the chosen stimulus condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">condition_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span>
        <span class="p">)</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="s1">&#39;stim_start_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">condition_stops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span><span class="o">.</span><span class="n">stim_condition_ids</span>
        <span class="p">)</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">condition</span><span class="p">)[</span><span class="s1">&#39;stim_stop_times&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="n">condition_starts</span><span class="p">,</span>
            <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="n">condition_stops</span>
        <span class="p">}</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a dictionary object of the start times and
stop times of a particular stimulus condition.</p>

<p>Args:</p>

<p>-condition: Condition id for the chosen stimulus condition.</p>
</div>


                            </div>
                            <div id="load_experiment.match_condition_parameters" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#load_experiment.match_condition_parameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">match_condition_parameters</span><span class="signature">(self, params_file)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">match_condition_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a parameters file and alters the .stim_data dataframe</span>
<span class="sd">        to match stimulus condition parameters to their corresponding </span>
<span class="sd">        condition id.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">        </span>
<span class="sd">        - params_file: Path to the stimulus parameters file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># </span>

        <span class="c1"># regex to get the parameter names + values</span>
        <span class="n">name_identifier</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;Var\d{1,}Val&#39;</span>
        <span class="n">val_identifier</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;var\d{1,}value&#39;</span>

        <span class="c1"># load the parameter file and extract the keys</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">params_file</span><span class="p">)</span>
        <span class="n">param_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="k">if</span> <span class="s1">&#39;fnames&#39;</span> <span class="ow">in</span> <span class="n">param_keys</span><span class="p">:</span> <span class="c1"># if experiment is natural images</span>
            
            <span class="c1"># get the stim file names</span>
            <span class="n">stim_file_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> 
                <span class="n">name</span> <span class="ow">in</span> <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">params_file</span><span class="p">)[</span><span class="s1">&#39;fnames&#39;</span><span class="p">]</span>
            <span class="p">]</span>
            
            <span class="c1"># make a dictionary for the parameter mapping</span>
            <span class="n">ni_filemap</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;condition&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;filter&#39;</span><span class="p">:</span> <span class="p">[],</span>
                <span class="s1">&#39;file&#39;</span><span class="p">:</span> <span class="p">[]</span>
            <span class="p">}</span>
            
            <span class="c1"># match condition to parameters</span>
            <span class="n">freg</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;^[A-Z]{2,3}&#39;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># if condition is even</span>
                    
                    <span class="c1">#append condition &amp; size</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
                    
                    <span class="c1">#append filename</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="n">stim_file_names</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> 
                    
                    <span class="c1">#append filtering condition</span>
                    <span class="n">filt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">freg</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
            
                <span class="k">else</span><span class="p">:</span> <span class="c1"># if condition is odd</span>
                    <span class="c1">#append condition &amp; size</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;condition&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
                    
                    <span class="c1">#append filename</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="n">stim_file_names</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                    
                    <span class="c1">#append filtering condition</span>
                    <span class="n">filt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">freg</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ni_filemap</span><span class="p">[</span><span class="s1">&#39;filter&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
                    
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ni_filemap</span><span class="p">)</span> 
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span>
            
            <span class="c1"># get the parameters to insert into the original dataframe</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">condition</span> <span class="o">==</span> <span class="n">cond</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">insert</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">insert</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># insert the parameter values into the original dataframe</span>
            <span class="n">df1</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">insert</span><span class="p">)</span>

            <span class="c1"># reset the stim_data attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="n">df1</span><span class="p">[</span>
                <span class="nb">list</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">)</span>
                <span class="p">]</span>
        
        <span class="k">else</span><span class="p">:</span> <span class="c1"># if experiment is gratings or checkerboard</span>
            <span class="c1"># use regex to get the param names and values</span>
            <span class="n">name_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">param_keys</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">name_identifier</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>
            <span class="n">val_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">param_keys</span> <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">val_identifier</span><span class="p">,</span> <span class="n">key</span><span class="p">)]</span>

            <span class="c1"># get the condition numbers</span>
            <span class="n">condition_range</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">val_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">condition_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">condition_range</span><span class="p">)]</span>

            <span class="c1"># map conditions to parameter values</span>
            <span class="n">parameter_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;condition&#39;</span><span class="p">:</span> <span class="n">condition_ids</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">name_keys</span><span class="p">)):</span>
                <span class="n">parameter_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">name_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">parameter_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">val_keys</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">parameter_map</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter_values</span>

                <span class="c1"># parameter dataframe + the original stim_data dataframe</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">parameter_map</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span>

            <span class="c1"># get the parameters to insert into the original dataframe</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">stim_condition_ids</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">condition</span> <span class="o">==</span> <span class="n">cond</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">insert</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="n">insert</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">insert</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># insert the parameter values into the original dataframe</span>
            <span class="n">df1</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">insert</span><span class="p">)</span>

            <span class="c1"># reset the stim_data attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stim_data</span> <span class="o">=</span> <span class="n">df1</span><span class="p">[</span>
                <span class="nb">list</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_map</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="p">)</span>
                <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parameters_matched</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>

        </details>

            <div class="docstring"><p>Takes a parameters file and alters the .stim_data dataframe
to match stimulus condition parameters to their corresponding 
condition id.</p>

<p>Args:</p>

<ul>
<li>params_file: Path to the stimulus parameters file.</li>
</ul>
</div>


                            </div>
                            <div id="load_experiment.population_response" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#load_experiment.population_response">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">population_response</span><span class="signature">(
    self,
    include_units,
    stim_condition=None,
    columns=&#39;cluster_id&#39;,
    thresh=None,
    norm=None
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">population_response</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">include_units</span><span class="p">,</span>  <span class="c1"># Units to include in the dataframe</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Stimulus condition(s) to include in the dataframe</span>
            <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span>  <span class="c1"># Set column label arrangement</span>
            <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Bounding threshold around the stimulus onset at t = 0 - pass as a tuple</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">None</span>  <span class="c1"># Normalization method - choose from: &#39;minmax&#39;, &#39;zscore&#39;, or &#39;average&#39;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dataframe of the population response PSTH.</span>
<span class="sd">        By default, each column label represents the</span>
<span class="sd">        included units. A single column identifies</span>
<span class="sd">        the stimulus condition at each row. Each row is the</span>
<span class="sd">        average response at each time step.</span>

<span class="sd">        Setting columns = &quot;stimulus_condition&quot; will</span>
<span class="sd">        return a data frame where each column label</span>
<span class="sd">        represents a stimulus condition. A single</span>
<span class="sd">        column identifes the included unit at each row.</span>
<span class="sd">        Each row is the average response at each time step.</span>

<span class="sd">        Args:</span>

<span class="sd">        - include_units: Units to include in the dataframe - pass as a 1d array or list like object.</span>
<span class="sd">        - stim_condition: Stimulus condition(s) to include in the dataframe - </span>
<span class="sd">          pass a list of condition ids or &#39;all&#39; to include all conditions.</span>
<span class="sd">        - columns: Set column label arrangement - pass either &#39;cluster_id&#39; or &#39;stimulus_condition&#39;. </span>
<span class="sd">          Default argument is &#39;stimulus_condition&#39;.</span>
<span class="sd">        - thresh: Bounding threshold around the stimulus onset at t = 0 - pass as a tuple.</span>
<span class="sd">        - norm: Normalization method - pass either &#39;minmax&#39;, &#39;zscore&#39;, or &#39;average&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Case checks:</span>
        <span class="k">if</span> <span class="n">stim_condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_NoStimulusCondition</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">stim_condition</span> <span class="ow">is</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">stim_condition</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stim_conditions</span><span class="p">)):</span> <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_UnrecognizedStimulusCondition</span><span class="p">()</span>

        <span class="n">col_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span> <span class="s1">&#39;stimulus_condition&#39;</span><span class="p">]</span> 
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col_formats</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_UnrecognizedColumnsInput</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">columns_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="k">elif</span> <span class="n">columns</span> <span class="o">==</span> <span class="s1">&#39;cluster_id&#39;</span><span class="p">:</span>
            <span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pr_unitcols</span><span class="p">(</span>
            <span class="n">include_units</span><span class="p">,</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="n">stim_condition</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">columns</span> <span class="o">==</span> <span class="s1">&#39;stimulus_condition&#39;</span><span class="p">:</span>
            <span class="n">population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pr_stimcols</span><span class="p">(</span>
            <span class="n">include_units</span><span class="p">,</span>
            <span class="n">stim_condition</span><span class="o">=</span><span class="n">stim_condition</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">thresh</span><span class="o">=</span><span class="n">thresh</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">population</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a dataframe of the population response PSTH.
By default, each column label represents the
included units. A single column identifies
the stimulus condition at each row. Each row is the
average response at each time step.</p>

<p>Setting columns = "stimulus_condition" will
return a data frame where each column label
represents a stimulus condition. A single
column identifes the included unit at each row.
Each row is the average response at each time step.</p>

<p>Args:</p>

<ul>
<li>include_units: Units to include in the dataframe - pass as a 1d array or list like object.</li>
<li>stim_condition: Stimulus condition(s) to include in the dataframe - 
pass a list of condition ids or 'all' to include all conditions.</li>
<li>columns: Set column label arrangement - pass either 'cluster_id' or 'stimulus_condition'. 
Default argument is 'stimulus_condition'.</li>
<li>thresh: Bounding threshold around the stimulus onset at t = 0 - pass as a tuple.</li>
<li>norm: Normalization method - pass either 'minmax', 'zscore', or 'average'.</li>
</ul>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#ephys_toolkit">ephys_toolkit</a></dt>
                                <dd id="load_experiment.static_grating" class="function"><a href="#ephys_toolkit.static_grating">static_grating</a></dd>
                <dd id="load_experiment.drifting_grating" class="function"><a href="#ephys_toolkit.drifting_grating">drifting_grating</a></dd>
                <dd id="load_experiment.spike_sorting_metrics" class="function"><a href="#ephys_toolkit.spike_sorting_metrics">spike_sorting_metrics</a></dd>
                <dd id="load_experiment.raster" class="function"><a href="#ephys_toolkit.raster">raster</a></dd>
                <dd id="load_experiment.avg_across_param" class="function"><a href="#ephys_toolkit.avg_across_param">avg_across_param</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="load_project">
                                <div class="attr class">
        <a class="headerlink" href="#load_project">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">load_project</span><wbr>(<span class="base"><a href="#ephys_toolkit">ephys_toolkit</a></span>):
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">load_project</span><span class="p">(</span><span class="n">ephys_toolkit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the load_project class with a full path to the</span>
<span class="sd">    directory containing the project files.</span>
<span class="sd">    </span>
<span class="sd">    The .workbook attribute contains a list of dictionaries</span>
<span class="sd">    with the following structure:</span>
<span class="sd">    </span>

<span class="sd">      </span>
<span class="sd">          {</span>
<span class="sd">          </span>
<span class="sd">              &#39;section_id&#39;: int,</span>
<span class="sd">              </span>
<span class="sd">              &#39;spike_sorting_metrics&#39;: dataframe,</span>
<span class="sd">              </span>
<span class="sd">              &#39;blocks&#39;: [</span>
<span class="sd">              </span>
<span class="sd">                  {&#39;block_id&#39;: int, &#39;experiment&#39;, experiment object},</span>
<span class="sd">                  </span>
<span class="sd">                  ]</span>
<span class="sd">                  </span>
<span class="sd">          },</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">    </span>
<span class="sd">    - project_path: Path to the directory containing the project files.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_path</span><span class="p">):</span>
        <span class="n">ephys_toolkit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppath</span> <span class="o">=</span> <span class="n">project_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_project_workbook</span><span class="p">()</span>

    <span class="c1"># generate the workbook of project data</span>
    <span class="k">def</span> <span class="nf">_init_project_workbook</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">explorer</span> <span class="o">=</span> <span class="n">path_explorer</span><span class="p">()</span>

        <span class="c1"># find and sort spike files</span>
        <span class="n">spike_files</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">findext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppath</span><span class="p">,</span> <span class="s1">&#39;.mat&#39;</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="s1">&#39;firings&#39;</span><span class="p">)</span>
        <span class="n">spike_files</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;BLK(\d{1,})&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># find and sort stim files</span>
        <span class="n">stim_files</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">findext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppath</span><span class="p">,</span> <span class="s1">&#39;.mat&#39;</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="s1">&#39;stimulusData&#39;</span><span class="p">)</span>
        <span class="n">stim_files</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;BLK(\d{1,})&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
        
        <span class="c1"># find and sort log files</span>
        <span class="n">log_files</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">findext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppath</span><span class="p">,</span> <span class="s1">&#39;.log&#39;</span><span class="p">)</span>
        <span class="n">log_files</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;BLK(\d{1,})&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
        
        <span class="c1"># count how many log files are in the data folder</span>
        <span class="n">log_diff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_files</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">log_files</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">log_diff</span><span class="p">):</span>
            <span class="n">log_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># zip matching blocks</span>
        <span class="n">matched_block_files</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spike_files</span><span class="p">,</span> <span class="n">stim_files</span><span class="p">,</span> <span class="n">log_files</span><span class="p">)</span>

        <span class="c1"># find metrics files</span>
        <span class="n">metrics_files</span> <span class="o">=</span> <span class="n">explorer</span><span class="o">.</span><span class="n">findext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppath</span><span class="p">,</span> <span class="s1">&#39;.json&#39;</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="s1">&#39;metrics_isolation&#39;</span><span class="p">)</span>

        <span class="c1">################################################################################</span>

        <span class="c1"># compile the workbook</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># compile spike sorting metrics first</span>
        <span class="k">for</span> <span class="n">metrics_file</span> <span class="ow">in</span> <span class="n">metrics_files</span><span class="p">:</span>
            <span class="n">section_parent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Section_(\d{1,})&#39;</span><span class="p">,</span> <span class="n">metrics_file</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spike_sorting_metrics</span><span class="p">(</span><span class="n">metrics_file</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s1">&#39;section_id&#39;</span><span class="p">:</span> <span class="n">section_parent</span><span class="p">,</span>
                    <span class="s1">&#39;spike_sorting_metrics&#39;</span><span class="p">:</span> <span class="n">df</span><span class="p">,</span>
                    <span class="s1">&#39;blocks&#39;</span><span class="p">:</span> <span class="p">[]</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="c1"># match experiment (block) objects to section</span>
        <span class="k">for</span> <span class="n">matched_files</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">matched_block_files</span><span class="p">):</span>
            <span class="c1"># a regex to get the experiment identity</span>
            <span class="n">ex_r</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;[A-Z]</span><span class="si">{2}</span><span class="s1">_M\d+_Section_\d+_BLK\d+&#39;</span> 
            <span class="n">experiment_id</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">ex_r</span><span class="p">,</span> <span class="n">matched_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="n">section_child</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Section_(\d{1,})&#39;</span><span class="p">,</span> <span class="n">matched_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">block</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;BLK(\d{1,})&#39;</span><span class="p">,</span> <span class="n">matched_files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

            <span class="n">experiment</span> <span class="o">=</span> <span class="n">load_experiment</span><span class="p">(</span><span class="o">*</span><span class="n">matched_files</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">workbook</span><span class="p">[</span><span class="n">section_child</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;blocks&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;block_id&#39;</span><span class="p">:</span> <span class="n">block</span><span class="p">,</span>
                <span class="s1">&#39;experiment&#39;</span><span class="p">:</span> <span class="n">experiment</span>
            <span class="p">})</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sucessfully loaded </span><span class="si">{</span><span class="n">experiment_id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Initialize the load_project class with a full path to the
directory containing the project files.</p>

<p>The .workbook attribute contains a list of dictionaries
with the following structure:</p>

<pre><code>  {

      'section_id': int,

      'spike_sorting_metrics': dataframe,

      'blocks': [

          {'block_id': int, 'experiment', experiment object},

          ]

  },
</code></pre>

<p>Args:</p>

<ul>
<li>project_path: Path to the directory containing the project files.</li>
</ul>
</div>


                            <div id="load_project.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#load_project.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">load_project</span><span class="signature">(project_path)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">project_path</span><span class="p">):</span>
        <span class="n">ephys_toolkit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppath</span> <span class="o">=</span> <span class="n">project_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_project_workbook</span><span class="p">()</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#ephys_toolkit">ephys_toolkit</a></dt>
                                <dd id="load_project.static_grating" class="function"><a href="#ephys_toolkit.static_grating">static_grating</a></dd>
                <dd id="load_project.drifting_grating" class="function"><a href="#ephys_toolkit.drifting_grating">drifting_grating</a></dd>
                <dd id="load_project.spike_sorting_metrics" class="function"><a href="#ephys_toolkit.spike_sorting_metrics">spike_sorting_metrics</a></dd>
                <dd id="load_project.raster" class="function"><a href="#ephys_toolkit.raster">raster</a></dd>
                <dd id="load_project.avg_across_param" class="function"><a href="#ephys_toolkit.avg_across_param">avg_across_param</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
    </main>
</body>
</html>